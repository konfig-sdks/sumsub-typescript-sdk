/* tslint:disable */
/* eslint-disable */
/*
Sumsub API

Sumsub is the one verification platform to secure the whole user journey. With Sumsub's customizable KYC, KYB, transaction monitoring and fraud prevention solutions, you can orchestrate your verification process, welcome more customers worldwide, meet compliance requirements, reduce costs and protect your business.

Sumsub has over 2,000 clients in fintech, crypto, transportation, trading, e-commerce and gaming industries including Binance, Wirex, Avis, Bybit, Huobi, Unlimit, Flutter, Kaizen Gaming, and TransferGo.

The version of the OpenAPI document: 1.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { TransactionApproveRejectRequest } from '../models';
// @ts-ignore
import { TransactionApproveRejectRequest1 } from '../models';
// @ts-ignore
import { TransactionBulkImportRequest } from '../models';
// @ts-ignore
import { TransactionBulkImportRequest1 } from '../models';
// @ts-ignore
import { TransactionBulkImportRequestData } from '../models';
// @ts-ignore
import { TransactionRemoveTagsRequest } from '../models';
// @ts-ignore
import { TransactionRemoveTagsRequest1 } from '../models';
// @ts-ignore
import { TransactionUpdateBlockchainInfoRequest } from '../models';
// @ts-ignore
import { TransactionUpdateBlockchainInfoRequest1 } from '../models';
// @ts-ignore
import { TransactionUpdatePropertiesRequest } from '../models';
// @ts-ignore
import { TransactionUpdatePropertiesRequest1 } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * TransactionApi - axios parameter creator
 * @export
 */
export const TransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Approves or rejects transactions.
         * @summary Approve and reject transaction
         * @param {string} id A unique transaction identification number.
         * @param {TransactionApproveRejectRequest} [transactionApproveRejectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveReject: async (id: string, transactionApproveRejectRequest?: TransactionApproveRejectRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('approveReject', 'id', id)
            const localVarPath = `/resources/kyt/txns/{id}/review/status/completed`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: transactionApproveRejectRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/kyt/txns/{id}/review/status/completed',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Imports a list of transactions.
         * @summary Bulk transaction import
         * @param {boolean} [ignoreErrors] &lt;ul&gt;&lt;li&gt;&lt;code&gt;true&lt;/code&gt; — all valid transactions will be created and returned, errors will be ignored during the processing and listed in the response.&lt;/li&gt;&lt;li&gt;&lt;code&gt;false&lt;/code&gt; (default) — valid transactions will be created up to the first detected error. The response will only contain the error on which the processing was interrupted.&lt;/li&gt;&lt;/ul&gt;
         * @param {boolean} [scoreSavedTxns] Allows you to control whether scoring should be run on imported transactions or not:&lt;ul&gt;&lt;li&gt;&lt;code&gt;true&lt;/code&gt; (default) — start scoring after import.&lt;/li&gt;&lt;li&gt;&lt;code&gt;false&lt;/code&gt; — do not start scoring after import.&lt;/li&gt;&lt;/ul&gt;
         * @param {TransactionBulkImportRequest} [transactionBulkImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkImport: async (ignoreErrors?: boolean, scoreSavedTxns?: boolean, transactionBulkImportRequest?: TransactionBulkImportRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/kyt/misc/txns/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })
            if (ignoreErrors !== undefined) {
                localVarQueryParameter['ignoreErrors'] = ignoreErrors;
            }

            if (scoreSavedTxns !== undefined) {
                localVarQueryParameter['scoreSavedTxns'] = scoreSavedTxns;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: transactionBulkImportRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/kyt/misc/txns/import',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Confirms that the specified transaction belongs to your exchange (VASP).
         * @summary Confirm transaction ownership
         * @param {string} txnId A unique transaction identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmOwnership: async (txnId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txnId' is not null or undefined
            assertParamExists('confirmOwnership', 'txnId', txnId)
            const localVarPath = `/resources/kyt/txns/{txnId}/ownership/confirmed`
                .replace(`{${"txnId"}}`, encodeURIComponent(String(txnId !== undefined ? txnId : `-txnId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/kyt/txns/{txnId}/ownership/confirmed',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns transaction information based on the provided `externalTxnId`.
         * @summary Get transaction information (externalTxnId)
         * @param {string} externalTxnId A unique transaction identifier on your side.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneData: async (externalTxnId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalTxnId' is not null or undefined
            assertParamExists('getOneData', 'externalTxnId', externalTxnId)
            const localVarPath = `/resources/kyt/txns/-;data.txnId={externalTxnId}/one`
                .replace(`{${"externalTxnId"}}`, encodeURIComponent(String(externalTxnId !== undefined ? externalTxnId : `-externalTxnId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/kyt/txns/-;data.txnId={externalTxnId}/one',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns transaction information.
         * @summary Get transaction information
         * @param {string} id A unique transaction identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        informationOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('informationOne', 'id', id)
            const localVarPath = `/resources/kyt/txns/{id}/one`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/kyt/txns/{id}/one',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of transaction tags.
         * @summary Get tags
         * @param {string} id A unique transaction identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listTags', 'id', id)
            const localVarPath = `/resources/kyt/txns/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/kyt/txns/{id}/tags',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Re-scores transactions.
         * @summary Re-score transaction
         * @param {string} id A unique transaction identification number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reScore: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reScore', 'id', id)
            const localVarPath = `/resources/kyt/txns/{id}/-/score`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/kyt/txns/{id}/-/score',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the ownership from a previously confirmed transaction.
         * @summary Remove transaction ownership
         * @param {string} txnId A unique transaction identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOwnership: async (txnId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txnId' is not null or undefined
            assertParamExists('removeOwnership', 'txnId', txnId)
            const localVarPath = `/resources/kyt/txns/{txnId}/ownership/unconfirmed`
                .replace(`{${"txnId"}}`, encodeURIComponent(String(txnId !== undefined ? txnId : `-txnId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/kyt/txns/{txnId}/ownership/unconfirmed',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes tags from transactions.
         * @summary Remove tags
         * @param {string} id A unique transaction identifier.
         * @param {TransactionRemoveTagsRequest} [transactionRemoveTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTags: async (id: string, transactionRemoveTagsRequest?: TransactionRemoveTagsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeTags', 'id', id)
            const localVarPath = `/resources/kyt/txns/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: transactionRemoveTagsRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/kyt/txns/{id}/tags',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates information from the blockchain.
         * @summary Patch transaction with chain transaction ID
         * @param {string} txnId A unique transaction identifier.
         * @param {TransactionUpdateBlockchainInfoRequest} [transactionUpdateBlockchainInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBlockchainInfo: async (txnId: string, transactionUpdateBlockchainInfoRequest?: TransactionUpdateBlockchainInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txnId' is not null or undefined
            assertParamExists('updateBlockchainInfo', 'txnId', txnId)
            const localVarPath = `/resources/kyt/txns/{txnId}/data/info`
                .replace(`{${"txnId"}}`, encodeURIComponent(String(txnId !== undefined ? txnId : `-txnId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: transactionUpdateBlockchainInfoRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/kyt/txns/{txnId}/data/info',
                httpMethod: 'PATCH'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates transaction properties.
         * @summary Change transaction properties
         * @param {string} id A unique transaction identification number.
         * @param {string} [unsetKeys] A list of property names separated by commas that should be set to &#x60;null&#x60;.
         * @param {TransactionUpdatePropertiesRequest} [transactionUpdatePropertiesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProperties: async (id: string, unsetKeys?: string, transactionUpdatePropertiesRequest?: TransactionUpdatePropertiesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProperties', 'id', id)
            const localVarPath = `/resources/kyt/txns/{id}/props`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })
            if (unsetKeys !== undefined) {
                localVarQueryParameter['unsetKeys'] = unsetKeys;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: transactionUpdatePropertiesRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/kyt/txns/{id}/props',
                httpMethod: 'PATCH'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionApi - functional programming interface
 * @export
 */
export const TransactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * Approves or rejects transactions.
         * @summary Approve and reject transaction
         * @param {TransactionApiApproveRejectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveReject(requestParameters: TransactionApiApproveRejectRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const transactionApproveRejectRequest: TransactionApproveRejectRequest = {
                reviewAnswer: requestParameters.reviewAnswer
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveReject(requestParameters.id, transactionApproveRejectRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Imports a list of transactions.
         * @summary Bulk transaction import
         * @param {TransactionApiBulkImportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkImport(requestParameters: TransactionApiBulkImportRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const transactionBulkImportRequest: TransactionBulkImportRequest = {
                applicantId: requestParameters.applicantId,
                data: requestParameters.data
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkImport(requestParameters.ignoreErrors, requestParameters.scoreSavedTxns, transactionBulkImportRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Confirms that the specified transaction belongs to your exchange (VASP).
         * @summary Confirm transaction ownership
         * @param {TransactionApiConfirmOwnershipRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmOwnership(requestParameters: TransactionApiConfirmOwnershipRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmOwnership(requestParameters.txnId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns transaction information based on the provided `externalTxnId`.
         * @summary Get transaction information (externalTxnId)
         * @param {TransactionApiGetOneDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOneData(requestParameters: TransactionApiGetOneDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOneData(requestParameters.externalTxnId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns transaction information.
         * @summary Get transaction information
         * @param {TransactionApiInformationOneRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async informationOne(requestParameters: TransactionApiInformationOneRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.informationOne(requestParameters.id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of transaction tags.
         * @summary Get tags
         * @param {TransactionApiListTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTags(requestParameters: TransactionApiListTagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTags(requestParameters.id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Re-scores transactions.
         * @summary Re-score transaction
         * @param {TransactionApiReScoreRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reScore(requestParameters: TransactionApiReScoreRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reScore(requestParameters.id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes the ownership from a previously confirmed transaction.
         * @summary Remove transaction ownership
         * @param {TransactionApiRemoveOwnershipRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeOwnership(requestParameters: TransactionApiRemoveOwnershipRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeOwnership(requestParameters.txnId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes tags from transactions.
         * @summary Remove tags
         * @param {TransactionApiRemoveTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTags(requestParameters: TransactionApiRemoveTagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const transactionRemoveTagsRequest: TransactionRemoveTagsRequest = {
                RAW_BODY: requestParameters.RAW_BODY
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTags(requestParameters.id, transactionRemoveTagsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates information from the blockchain.
         * @summary Patch transaction with chain transaction ID
         * @param {TransactionApiUpdateBlockchainInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBlockchainInfo(requestParameters: TransactionApiUpdateBlockchainInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const transactionUpdateBlockchainInfoRequest: TransactionUpdateBlockchainInfoRequest = {
                fingerprint: requestParameters.fingerprint
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBlockchainInfo(requestParameters.txnId, transactionUpdateBlockchainInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates transaction properties.
         * @summary Change transaction properties
         * @param {TransactionApiUpdatePropertiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProperties(requestParameters: TransactionApiUpdatePropertiesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const transactionUpdatePropertiesRequest: TransactionUpdatePropertiesRequest = {
                customProperty: requestParameters.customProperty
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProperties(requestParameters.id, requestParameters.unsetKeys, transactionUpdatePropertiesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionApi - factory interface
 * @export
 */
export const TransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionApiFp(configuration)
    return {
        /**
         * Approves or rejects transactions.
         * @summary Approve and reject transaction
         * @param {TransactionApiApproveRejectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveReject(requestParameters: TransactionApiApproveRejectRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.approveReject(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Imports a list of transactions.
         * @summary Bulk transaction import
         * @param {TransactionApiBulkImportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkImport(requestParameters: TransactionApiBulkImportRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.bulkImport(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Confirms that the specified transaction belongs to your exchange (VASP).
         * @summary Confirm transaction ownership
         * @param {TransactionApiConfirmOwnershipRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmOwnership(requestParameters: TransactionApiConfirmOwnershipRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.confirmOwnership(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns transaction information based on the provided `externalTxnId`.
         * @summary Get transaction information (externalTxnId)
         * @param {TransactionApiGetOneDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneData(requestParameters: TransactionApiGetOneDataRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getOneData(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns transaction information.
         * @summary Get transaction information
         * @param {TransactionApiInformationOneRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        informationOne(requestParameters: TransactionApiInformationOneRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.informationOne(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of transaction tags.
         * @summary Get tags
         * @param {TransactionApiListTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags(requestParameters: TransactionApiListTagsRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.listTags(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Re-scores transactions.
         * @summary Re-score transaction
         * @param {TransactionApiReScoreRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reScore(requestParameters: TransactionApiReScoreRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.reScore(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the ownership from a previously confirmed transaction.
         * @summary Remove transaction ownership
         * @param {TransactionApiRemoveOwnershipRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOwnership(requestParameters: TransactionApiRemoveOwnershipRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeOwnership(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes tags from transactions.
         * @summary Remove tags
         * @param {TransactionApiRemoveTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTags(requestParameters: TransactionApiRemoveTagsRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeTags(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates information from the blockchain.
         * @summary Patch transaction with chain transaction ID
         * @param {TransactionApiUpdateBlockchainInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBlockchainInfo(requestParameters: TransactionApiUpdateBlockchainInfoRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.updateBlockchainInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates transaction properties.
         * @summary Change transaction properties
         * @param {TransactionApiUpdatePropertiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProperties(requestParameters: TransactionApiUpdatePropertiesRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateProperties(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for approveReject operation in TransactionApi.
 * @export
 * @interface TransactionApiApproveRejectRequest
 */
export type TransactionApiApproveRejectRequest = {
    
    /**
    * A unique transaction identification number.
    * @type {string}
    * @memberof TransactionApiApproveReject
    */
    readonly id: string
    
} & TransactionApproveRejectRequest

/**
 * Request parameters for bulkImport operation in TransactionApi.
 * @export
 * @interface TransactionApiBulkImportRequest
 */
export type TransactionApiBulkImportRequest = {
    
    /**
    * <ul><li><code>true</code> — all valid transactions will be created and returned, errors will be ignored during the processing and listed in the response.</li><li><code>false</code> (default) — valid transactions will be created up to the first detected error. The response will only contain the error on which the processing was interrupted.</li></ul>
    * @type {boolean}
    * @memberof TransactionApiBulkImport
    */
    readonly ignoreErrors?: boolean
    
    /**
    * Allows you to control whether scoring should be run on imported transactions or not:<ul><li><code>true</code> (default) — start scoring after import.</li><li><code>false</code> — do not start scoring after import.</li></ul>
    * @type {boolean}
    * @memberof TransactionApiBulkImport
    */
    readonly scoreSavedTxns?: boolean
    
} & TransactionBulkImportRequest

/**
 * Request parameters for confirmOwnership operation in TransactionApi.
 * @export
 * @interface TransactionApiConfirmOwnershipRequest
 */
export type TransactionApiConfirmOwnershipRequest = {
    
    /**
    * A unique transaction identifier.
    * @type {string}
    * @memberof TransactionApiConfirmOwnership
    */
    readonly txnId: string
    
}

/**
 * Request parameters for getOneData operation in TransactionApi.
 * @export
 * @interface TransactionApiGetOneDataRequest
 */
export type TransactionApiGetOneDataRequest = {
    
    /**
    * A unique transaction identifier on your side.
    * @type {string}
    * @memberof TransactionApiGetOneData
    */
    readonly externalTxnId: string
    
}

/**
 * Request parameters for informationOne operation in TransactionApi.
 * @export
 * @interface TransactionApiInformationOneRequest
 */
export type TransactionApiInformationOneRequest = {
    
    /**
    * A unique transaction identifier.
    * @type {string}
    * @memberof TransactionApiInformationOne
    */
    readonly id: string
    
}

/**
 * Request parameters for listTags operation in TransactionApi.
 * @export
 * @interface TransactionApiListTagsRequest
 */
export type TransactionApiListTagsRequest = {
    
    /**
    * A unique transaction identifier.
    * @type {string}
    * @memberof TransactionApiListTags
    */
    readonly id: string
    
}

/**
 * Request parameters for reScore operation in TransactionApi.
 * @export
 * @interface TransactionApiReScoreRequest
 */
export type TransactionApiReScoreRequest = {
    
    /**
    * A unique transaction identification number.
    * @type {string}
    * @memberof TransactionApiReScore
    */
    readonly id: string
    
}

/**
 * Request parameters for removeOwnership operation in TransactionApi.
 * @export
 * @interface TransactionApiRemoveOwnershipRequest
 */
export type TransactionApiRemoveOwnershipRequest = {
    
    /**
    * A unique transaction identifier.
    * @type {string}
    * @memberof TransactionApiRemoveOwnership
    */
    readonly txnId: string
    
}

/**
 * Request parameters for removeTags operation in TransactionApi.
 * @export
 * @interface TransactionApiRemoveTagsRequest
 */
export type TransactionApiRemoveTagsRequest = {
    
    /**
    * A unique transaction identifier.
    * @type {string}
    * @memberof TransactionApiRemoveTags
    */
    readonly id: string
    
} & TransactionRemoveTagsRequest

/**
 * Request parameters for updateBlockchainInfo operation in TransactionApi.
 * @export
 * @interface TransactionApiUpdateBlockchainInfoRequest
 */
export type TransactionApiUpdateBlockchainInfoRequest = {
    
    /**
    * A unique transaction identifier.
    * @type {string}
    * @memberof TransactionApiUpdateBlockchainInfo
    */
    readonly txnId: string
    
} & TransactionUpdateBlockchainInfoRequest

/**
 * Request parameters for updateProperties operation in TransactionApi.
 * @export
 * @interface TransactionApiUpdatePropertiesRequest
 */
export type TransactionApiUpdatePropertiesRequest = {
    
    /**
    * A unique transaction identification number.
    * @type {string}
    * @memberof TransactionApiUpdateProperties
    */
    readonly id: string
    
    /**
    * A list of property names separated by commas that should be set to `null`.
    * @type {string}
    * @memberof TransactionApiUpdateProperties
    */
    readonly unsetKeys?: string
    
} & TransactionUpdatePropertiesRequest

/**
 * TransactionApiGenerated - object-oriented interface
 * @export
 * @class TransactionApiGenerated
 * @extends {BaseAPI}
 */
export class TransactionApiGenerated extends BaseAPI {
    /**
     * Approves or rejects transactions.
     * @summary Approve and reject transaction
     * @param {TransactionApiApproveRejectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApiGenerated
     */
    public approveReject(requestParameters: TransactionApiApproveRejectRequest, options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).approveReject(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Imports a list of transactions.
     * @summary Bulk transaction import
     * @param {TransactionApiBulkImportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApiGenerated
     */
    public bulkImport(requestParameters: TransactionApiBulkImportRequest, options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).bulkImport(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Confirms that the specified transaction belongs to your exchange (VASP).
     * @summary Confirm transaction ownership
     * @param {TransactionApiConfirmOwnershipRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApiGenerated
     */
    public confirmOwnership(requestParameters: TransactionApiConfirmOwnershipRequest, options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).confirmOwnership(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns transaction information based on the provided `externalTxnId`.
     * @summary Get transaction information (externalTxnId)
     * @param {TransactionApiGetOneDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApiGenerated
     */
    public getOneData(requestParameters: TransactionApiGetOneDataRequest, options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).getOneData(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns transaction information.
     * @summary Get transaction information
     * @param {TransactionApiInformationOneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApiGenerated
     */
    public informationOne(requestParameters: TransactionApiInformationOneRequest, options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).informationOne(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of transaction tags.
     * @summary Get tags
     * @param {TransactionApiListTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApiGenerated
     */
    public listTags(requestParameters: TransactionApiListTagsRequest, options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).listTags(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Re-scores transactions.
     * @summary Re-score transaction
     * @param {TransactionApiReScoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApiGenerated
     */
    public reScore(requestParameters: TransactionApiReScoreRequest, options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).reScore(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the ownership from a previously confirmed transaction.
     * @summary Remove transaction ownership
     * @param {TransactionApiRemoveOwnershipRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApiGenerated
     */
    public removeOwnership(requestParameters: TransactionApiRemoveOwnershipRequest, options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).removeOwnership(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes tags from transactions.
     * @summary Remove tags
     * @param {TransactionApiRemoveTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApiGenerated
     */
    public removeTags(requestParameters: TransactionApiRemoveTagsRequest, options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).removeTags(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates information from the blockchain.
     * @summary Patch transaction with chain transaction ID
     * @param {TransactionApiUpdateBlockchainInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApiGenerated
     */
    public updateBlockchainInfo(requestParameters: TransactionApiUpdateBlockchainInfoRequest, options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).updateBlockchainInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates transaction properties.
     * @summary Change transaction properties
     * @param {TransactionApiUpdatePropertiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApiGenerated
     */
    public updateProperties(requestParameters: TransactionApiUpdatePropertiesRequest, options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).updateProperties(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
