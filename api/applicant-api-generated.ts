/* tslint:disable */
/* eslint-disable */
/*
Sumsub API

Sumsub is the one verification platform to secure the whole user journey. With Sumsub's customizable KYC, KYB, transaction monitoring and fraud prevention solutions, you can orchestrate your verification process, welcome more customers worldwide, meet compliance requirements, reduce costs and protect your business.

Sumsub has over 2,000 clients in fintech, crypto, transportation, trading, e-commerce and gaming industries including Binance, Wirex, Avis, Bybit, Huobi, Unlimit, Flutter, Kaizen Gaming, and TransferGo.

The version of the OpenAPI document: 1.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ApplicantAddBeneficiaryRequest } from '../models';
// @ts-ignore
import { ApplicantAddBeneficiaryRequest1 } from '../models';
// @ts-ignore
import { ApplicantAddBeneficiaryRequestApplicant } from '../models';
// @ts-ignore
import { ApplicantAddConsentToProfileRequest } from '../models';
// @ts-ignore
import { ApplicantAddConsentToProfileRequest1 } from '../models';
// @ts-ignore
import { ApplicantAddConsentToProfileRequestRecordsInner } from '../models';
// @ts-ignore
import { ApplicantAddCustomTagsRequest } from '../models';
// @ts-ignore
import { ApplicantAddCustomTagsRequest1 } from '../models';
// @ts-ignore
import { ApplicantAddCustomTagsRequest2 } from '../models';
// @ts-ignore
import { ApplicantAddCustomTagsRequest3 } from '../models';
// @ts-ignore
import { ApplicantAddIdDocumentRequest } from '../models';
// @ts-ignore
import { ApplicantAddIdDocumentRequest1 } from '../models';
// @ts-ignore
import { ApplicantAddIdDocumentRequestMetadata } from '../models';
// @ts-ignore
import { ApplicantAddIdDocumentResponse } from '../models';
// @ts-ignore
import { ApplicantAddImageToPaymentMethodRequest } from '../models';
// @ts-ignore
import { ApplicantAddImageToPaymentMethodRequest1 } from '../models';
// @ts-ignore
import { ApplicantAddImageToPaymentMethodRequestMetadata } from '../models';
// @ts-ignore
import { ApplicantAddPaymentMethodInformationRequest } from '../models';
// @ts-ignore
import { ApplicantAddPaymentMethodInformationRequest1 } from '../models';
// @ts-ignore
import { ApplicantChangeCompanyDataRequest } from '../models';
// @ts-ignore
import { ApplicantChangeCompanyDataRequest1 } from '../models';
// @ts-ignore
import { ApplicantChangeExtractedInfoRequest } from '../models';
// @ts-ignore
import { ApplicantChangeExtractedInfoRequest1 } from '../models';
// @ts-ignore
import { ApplicantConfirmDataRequest } from '../models';
// @ts-ignore
import { ApplicantConfirmDataRequest1 } from '../models';
// @ts-ignore
import { ApplicantConfirmDataRequestOauth } from '../models';
// @ts-ignore
import { ApplicantConfirmDataRequestOtp } from '../models';
// @ts-ignore
import { ApplicantCreateActionRequest } from '../models';
// @ts-ignore
import { ApplicantCreateActionRequest1 } from '../models';
// @ts-ignore
import { ApplicantCreateActionRequestPaymentMethod } from '../models';
// @ts-ignore
import { ApplicantCreateActionRequestPaymentMethodData } from '../models';
// @ts-ignore
import { ApplicantCreateCryptoSourceOfFundsRequest } from '../models';
// @ts-ignore
import { ApplicantCreateCryptoSourceOfFundsRequest1 } from '../models';
// @ts-ignore
import { ApplicantCreatePaymentSourceActionsRequest } from '../models';
// @ts-ignore
import { ApplicantCreatePaymentSourceActionsRequest1 } from '../models';
// @ts-ignore
import { ApplicantCreatePaymentSourceActionsRequestPaymentSource } from '../models';
// @ts-ignore
import { ApplicantCreatePaymentSourceActionsResponse } from '../models';
// @ts-ignore
import { ApplicantEnrichTransactionWithTravelRuleDataRequest } from '../models';
// @ts-ignore
import { ApplicantEnrichTransactionWithTravelRuleDataRequest1 } from '../models';
// @ts-ignore
import { ApplicantImportByArchiveRequest } from '../models';
// @ts-ignore
import { ApplicantImportByArchiveRequest1 } from '../models';
// @ts-ignore
import { ApplicantImportCompletedRequest } from '../models';
// @ts-ignore
import { ApplicantImportCompletedRequest1 } from '../models';
// @ts-ignore
import { ApplicantImportCompletedRequestInfo } from '../models';
// @ts-ignore
import { ApplicantImportCompletedRequestReview } from '../models';
// @ts-ignore
import { ApplicantRemoveCustomTagsRequest } from '../models';
// @ts-ignore
import { ApplicantRemoveCustomTagsRequest1 } from '../models';
// @ts-ignore
import { ApplicantSandboxVerificationResponseRequest } from '../models';
// @ts-ignore
import { ApplicantSandboxVerificationResponseRequest1 } from '../models';
// @ts-ignore
import { ApplicantSubmitDataNoDocVerificationRequest } from '../models';
// @ts-ignore
import { ApplicantSubmitDataNoDocVerificationRequest1 } from '../models';
// @ts-ignore
import { ApplicantSubmitDataNoDocVerificationRequestInfo } from '../models';
// @ts-ignore
import { ApplicantSubmitTransactionDataRequest } from '../models';
// @ts-ignore
import { ApplicantSubmitTransactionDataRequest1 } from '../models';
// @ts-ignore
import { ApplicantSubmitTransactionDataRequestApplicant } from '../models';
// @ts-ignore
import { ApplicantSubmitTransactionDataRequestCounterparty } from '../models';
// @ts-ignore
import { ApplicantSubmitTransactionDataRequestInfo } from '../models';
// @ts-ignore
import { ApplicantSubmitTransactionDataRequestProps } from '../models';
// @ts-ignore
import { ApplicantSubmitTransactionForNonExistingRequest } from '../models';
// @ts-ignore
import { ApplicantSubmitTransactionForNonExistingRequest1 } from '../models';
// @ts-ignore
import { ApplicantSubmitTransactionForNonExistingRequestApplicant } from '../models';
// @ts-ignore
import { ApplicantSubmitTransactionForNonExistingRequestCounterparty } from '../models';
// @ts-ignore
import { ApplicantUpdateFixedInfoRequest } from '../models';
// @ts-ignore
import { ApplicantUpdateFixedInfoRequest1 } from '../models';
// @ts-ignore
import { ApplicantUpdateTopLevelInfoRequest } from '../models';
// @ts-ignore
import { ApplicantUpdateTopLevelInfoRequest1 } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * ApplicantApi - axios parameter creator
 * @export
 */
export const ApplicantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds an existing individual applicant as a beneficiary.
         * @summary Add applicant as beneficiary
         * @param {string} applicantId A unique company applicant identifier.
         * @param {ApplicantAddBeneficiaryRequest} [applicantAddBeneficiaryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBeneficiary: async (applicantId: string, applicantAddBeneficiaryRequest?: ApplicantAddBeneficiaryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('addBeneficiary', 'applicantId', applicantId)
            const localVarPath = `/resources/applicants/{applicantId}/info/companyInfo/beneficiaries`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: applicantAddBeneficiaryRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/{applicantId}/info/companyInfo/beneficiaries',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a consent to an applicant profile.
         * @summary Add applicant consent
         * @param {string} applicantId A unique identifier of an applicant profile to which a consent should be added.
         * @param {ApplicantAddConsentToProfileRequest} [applicantAddConsentToProfileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addConsentToProfile: async (applicantId: string, applicantAddConsentToProfileRequest?: ApplicantAddConsentToProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('addConsentToProfile', 'applicantId', applicantId)
            const localVarPath = `/resources/applicants/{applicantId}/agreement`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: applicantAddConsentToProfileRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/{applicantId}/agreement',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds custom tags to applicant profiles.
         * @summary Add custom applicant tags
         * @param {string} applicantId A unique applicant identifier.
         * @param {ApplicantAddCustomTagsRequest} [applicantAddCustomTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCustomTags: async (applicantId: string, applicantAddCustomTagsRequest?: ApplicantAddCustomTagsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('addCustomTags', 'applicantId', applicantId)
            const localVarPath = `/resources/applicants/{applicantId}/tags/add`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: applicantAddCustomTagsRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/{applicantId}/tags/add',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds and overwrites custom tags in applicant profiles.
         * @summary Add and overwrite custom applicant tags
         * @param {string} applicantId A unique applicant identifier.
         * @param {ApplicantAddCustomTagsRequest2} [applicantAddCustomTagsRequest2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCustomTags_1: async (applicantId: string, applicantAddCustomTagsRequest2?: ApplicantAddCustomTagsRequest2, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('addCustomTags_1', 'applicantId', applicantId)
            const localVarPath = `/resources/applicants/{applicantId}/tags`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: applicantAddCustomTagsRequest2,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/{applicantId}/tags',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds an identification document to be verified.
         * @summary Add ID document
         * @param {boolean} xReturnDocWarnings &#x60;true&#x60; / &#x60;false&#x60;
         * @param {string} applicantId A unique applicant identifier.
         * @param {ApplicantAddIdDocumentRequest} [applicantAddIdDocumentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addIdDocument: async (xReturnDocWarnings: boolean, applicantId: string, applicantAddIdDocumentRequest?: ApplicantAddIdDocumentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xReturnDocWarnings' is not null or undefined
            assertParamExists('addIdDocument', 'xReturnDocWarnings', xReturnDocWarnings)
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('addIdDocument', 'applicantId', applicantId)
            const localVarPath = `/resources/applicants/{applicantId}/info/idDoc`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })
            if (xReturnDocWarnings != null) {
                localVarHeaderParameter['X-Return-Doc-Warnings'] = typeof xReturnDocWarnings === 'string'
                    ? xReturnDocWarnings
                    : JSON.stringify(xReturnDocWarnings);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: applicantAddIdDocumentRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/{applicantId}/info/idDoc',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds an image to the payment method.
         * @summary Add image to payment method
         * @param {string} actionId A unique applicant action identifier.
         * @param {ApplicantAddImageToPaymentMethodRequest} [applicantAddImageToPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addImageToPaymentMethod: async (actionId: string, applicantAddImageToPaymentMethodRequest?: ApplicantAddImageToPaymentMethodRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            assertParamExists('addImageToPaymentMethod', 'actionId', actionId)
            const localVarPath = `/resources/applicantActions/{actionId}/images`
                .replace(`{${"actionId"}}`, encodeURIComponent(String(actionId !== undefined ? actionId : `-actionId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: applicantAddImageToPaymentMethodRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicantActions/{actionId}/images',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds additional information to the payment method.
         * @summary Add payment method information
         * @param {string} actionId A unique applicant action identifier.
         * @param {ApplicantAddPaymentMethodInformationRequest} [applicantAddPaymentMethodInformationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPaymentMethodInformation: async (actionId: string, applicantAddPaymentMethodInformationRequest?: ApplicantAddPaymentMethodInformationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            assertParamExists('addPaymentMethodInformation', 'actionId', actionId)
            const localVarPath = `/resources/applicantActions/{actionId}/paymentMethod`
                .replace(`{${"actionId"}}`, encodeURIComponent(String(actionId !== undefined ? actionId : `-actionId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: applicantAddPaymentMethodInformationRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicantActions/{actionId}/paymentMethod',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add an applicant to blocklist.
         * @summary Add applicant to blocklist
         * @param {string} note A note indicating the reason for blocklisting the applicant profile.
         * @param {string} applicantId A unique applicant identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToBlocklist: async (note: string, applicantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'note' is not null or undefined
            assertParamExists('addToBlocklist', 'note', note)
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('addToBlocklist', 'applicantId', applicantId)
            const localVarPath = `/resources/applicants/{applicantId}/blacklist?note={note}`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })
            if (note !== undefined) {
                localVarQueryParameter['note'] = note;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/{applicantId}/blacklist?note={note}',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes company data.
         * @summary Change company data
         * @param {string} applicantId A unique applicant identifier.
         * @param {ApplicantChangeCompanyDataRequest} [applicantChangeCompanyDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeCompanyData: async (applicantId: string, applicantChangeCompanyDataRequest?: ApplicantChangeCompanyDataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('changeCompanyData', 'applicantId', applicantId)
            const localVarPath = `/resources/applicants/{applicantId}/info/companyInfo`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: applicantChangeCompanyDataRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/{applicantId}/info/companyInfo',
                httpMethod: 'PATCH'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes extracted information.
         * @summary Change information extracted by Sumsub
         * @param {string} applicantId A unique applicant identifier.
         * @param {ApplicantChangeExtractedInfoRequest} [applicantChangeExtractedInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeExtractedInfo: async (applicantId: string, applicantChangeExtractedInfoRequest?: ApplicantChangeExtractedInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('changeExtractedInfo', 'applicantId', applicantId)
            const localVarPath = `/resources/applicants/{applicantId}/info`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: applicantChangeExtractedInfoRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/{applicantId}/info',
                httpMethod: 'PATCH'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the list of required documents.
         * @summary Change required document set
         * @param {string} name A [verification level](https://docs.sumsub.com/reference) name. Case-sensitive and has to be created in the same environment. If contains reserved characters (e.g., &#x60;@&#x60;, &#x60;+\&quot;&#x60;, white spaces as &#x60;%20&#x60;), it should be URL-encoded, otherwise you may get signature mismatch.
         * @param {string} applicantId A unique applicant identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeRequiredDocumentSet: async (name: string, applicantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('changeRequiredDocumentSet', 'name', name)
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('changeRequiredDocumentSet', 'applicantId', applicantId)
            const localVarPath = `/resources/applicants/{applicantId}/moveToLevel`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/{applicantId}/moveToLevel',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns rejection reason clarification.
         * @summary Clarify rejection reason
         * @param {string} applicantId A unique applicant identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clarifyRejectionReason: async (applicantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('clarifyRejectionReason', 'applicantId', applicantId)
            const localVarPath = `/resources/moderationStates/-;applicantId={applicantId}`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/moderationStates/-;applicantId={applicantId}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Confirms applicant data.
         * @summary Confirm applicant data
         * @param {string} applicantId A unique applicant identifier.
         * @param {string} confirmationId A confirmation identifier from the [submission](ref:submit-applicant-data) response.
         * @param {ApplicantConfirmDataRequest} [applicantConfirmDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmData: async (applicantId: string, confirmationId: string, applicantConfirmDataRequest?: ApplicantConfirmDataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('confirmData', 'applicantId', applicantId)
            // verify required parameter 'confirmationId' is not null or undefined
            assertParamExists('confirmData', 'confirmationId', confirmationId)
            const localVarPath = `/resources/applicants/{applicantId}/ekyc/confirm/{confirmationid}`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)))
                .replace(`{${"confirmationId"}}`, encodeURIComponent(String(confirmationId !== undefined ? confirmationId : `-confirmationId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: applicantConfirmDataRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/{applicantId}/ekyc/confirm/{confirmationid}',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an applicant action.
         * @summary Create applicant action
         * @param {string} applicantId A unique aplicant identifier.
         * @param {string} levelName A name of the level configured in the dashboard.
         * @param {ApplicantCreateActionRequest} [applicantCreateActionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAction: async (applicantId: string, levelName: string, applicantCreateActionRequest?: ApplicantCreateActionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('createAction', 'applicantId', applicantId)
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('createAction', 'levelName', levelName)
            const localVarPath = `/resources/applicantActions/-/forApplicant/{applicantId}?levelName={levelName}`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })
            if (levelName !== undefined) {
                localVarQueryParameter['levelName'] = levelName;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: applicantCreateActionRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicantActions/-/forApplicant/{applicantId}?levelName={levelName}',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an action with transaction information.
         * @summary Submission
         * @param {string} applicantId A unique applicant identifier.
         * @param {ApplicantCreateCryptoSourceOfFundsRequest} [applicantCreateCryptoSourceOfFundsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCryptoSourceOfFunds: async (applicantId: string, applicantCreateCryptoSourceOfFundsRequest?: ApplicantCreateCryptoSourceOfFundsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('createCryptoSourceOfFunds', 'applicantId', applicantId)
            const localVarPath = `/resources/applicantActions/-/forApplicant/{applicantId}/cryptoSourceOfFunds`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: applicantCreateCryptoSourceOfFundsRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicantActions/-/forApplicant/{applicantId}/cryptoSourceOfFunds',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an action to process a payment source and to confirm the owner of the payment method.
         * @summary Create payment source actions
         * @param {string} applicantId An unique applicant identifier.
         * @param {string} levelName A verification level name for which you want to create a payment source action.
         * @param {ApplicantCreatePaymentSourceActionsRequest} [applicantCreatePaymentSourceActionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentSourceActions: async (applicantId: string, levelName: string, applicantCreatePaymentSourceActionsRequest?: ApplicantCreatePaymentSourceActionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('createPaymentSourceActions', 'applicantId', applicantId)
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('createPaymentSourceActions', 'levelName', levelName)
            const localVarPath = `/resources/applicantActions/-/forApplicant/{applicantId}/?levelName=paymentSource`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })
            if (levelName !== undefined) {
                localVarQueryParameter['levelName'] = levelName;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: applicantCreatePaymentSourceActionsRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicantActions/-/forApplicant/{applicantId}/?levelName=paymentSource',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivates an applicant profile.
         * @summary Deactivate applicant profile
         * @param {string} applicantId A unique applicant identifier.
         * @param {string} status Possible values: &#x60;deactivated&#x60; to deactivate the applicant profile. &#x60;activated&#x60; to reactivate the applicant profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateProfile: async (applicantId: string, status: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('deactivateProfile', 'applicantId', applicantId)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('deactivateProfile', 'status', status)
            const localVarPath = `/resources/applicants/{applicantId}/presence/{status}`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status !== undefined ? status : `-status-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/{applicantId}/presence/{status}',
                httpMethod: 'PATCH'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enriches transaction with the Travel Rule data.
         * @summary Enriching transaction with Travel Rule
         * @param {string} txnId A unique transaction identifier.
         * @param {ApplicantEnrichTransactionWithTravelRuleDataRequest} [applicantEnrichTransactionWithTravelRuleDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrichTransactionWithTravelRuleData: async (txnId: string, applicantEnrichTransactionWithTravelRuleDataRequest?: ApplicantEnrichTransactionWithTravelRuleDataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txnId' is not null or undefined
            assertParamExists('enrichTransactionWithTravelRuleData', 'txnId', txnId)
            const localVarPath = `/resources/kyt/txns/{txnId}/data/applicant`
                .replace(`{${"txnId"}}`, encodeURIComponent(String(txnId !== undefined ? txnId : `-txnId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: applicantEnrichTransactionWithTravelRuleDataRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/kyt/txns/{txnId}/data/applicant',
                httpMethod: 'PATCH'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about the applicant action checks.
         * @summary Get action information
         * @param {string} actionId A unique applicant action identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionOneInfo: async (actionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            assertParamExists('getActionOneInfo', 'actionId', actionId)
            const localVarPath = `/resources/applicantActions/{actionId}/one`
                .replace(`{${"actionId"}}`, encodeURIComponent(String(actionId !== undefined ? actionId : `-actionId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicantActions/{actionId}/one',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of applicant actions.
         * @summary Get applicant actions
         * @param {string} applicantId A unique applicant identifier.
         * @param {number} [limit] Limit of applicant actions to be returned.
         * @param {number} [offset] Offset of applicant actions to be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActions: async (applicantId: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('getActions', 'applicantId', applicantId)
            const localVarPath = `/resources/applicantActions/-;applicantId={applicantId}`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicantActions/-;applicantId={applicantId}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an original bank card image.
         * @summary Get bank card image
         * @param {string} actionId A unique applicant action identifier.
         * @param {string} imageId An image identifier taken from &#x60;images[].imageId&#x60;.
         * @param {boolean} [isPreview] Indicates if an image thumbnail should be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBankCardImage: async (actionId: string, imageId: string, isPreview?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            assertParamExists('getBankCardImage', 'actionId', actionId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('getBankCardImage', 'imageId', imageId)
            const localVarPath = `/resources/applicantActions/{actionId}/images/{imageId}?preview={isPreview}`
                .replace(`{${"actionId"}}`, encodeURIComponent(String(actionId !== undefined ? actionId : `-actionId-`)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId !== undefined ? imageId : `-imageId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })
            if (isPreview !== undefined) {
                localVarQueryParameter['isPreview'] = isPreview;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicantActions/{actionId}/images/{imageId}?preview={isPreview}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns applicant information.
         * @summary Get applicant data
         * @param {string} applicantId A unique applicant identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getData: async (applicantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('getData', 'applicantId', applicantId)
            const localVarPath = `/resources/applicants/{applicantId}/one`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/{applicantId}/one',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns applicant information based on the provided `externalUserId`.
         * @summary Get applicant data (externalUserId)
         * @param {string} externalUserId A unique applicant identifier in your system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataByExternalUserId: async (externalUserId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalUserId' is not null or undefined
            assertParamExists('getDataByExternalUserId', 'externalUserId', externalUserId)
            const localVarPath = `/resources/applicants/-;externalUserId={externalUserId}/one`
                .replace(`{${"externalUserId"}}`, encodeURIComponent(String(externalUserId !== undefined ? externalUserId : `-externalUserId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/-;externalUserId={externalUserId}/one',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the applicant data for Non-Doc verification.
         * @summary Get applicant data
         * @param {'E_KYC_CHECK' | 'RESIDENCY_CHECK'} type Check type.
         * @param {string} applicantId A unique applicant identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataLatest: async (type: 'E_KYC_CHECK' | 'RESIDENCY_CHECK', applicantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getDataLatest', 'type', type)
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('getDataLatest', 'applicantId', applicantId)
            const localVarPath = `/resources/checks/latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (applicantId !== undefined) {
                localVarQueryParameter['applicantId'] = applicantId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/checks/latest',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns fraud network by `networkId`.
         * @summary Get fraud network by ID
         * @param {string} networkId A unique network identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFraudNetworkById: async (networkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('getFraudNetworkById', 'networkId', networkId)
            const localVarPath = `/resources/applicantFraudNetworks/{networkId}/one`
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId !== undefined ? networkId : `-networkId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicantFraudNetworks/{networkId}/one',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns fraud networks.
         * @summary Get fraud networks
         * @param {number} [offset] Offset of the found networks to be returned.
         * @param {number} [limit] Maximum number of the found networks to be returned. The maximum value you can set is 100.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFraudNetworks: async (offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/applicantFraudNetworks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicantFraudNetworks',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all fraud networks by `applicantId`.
         * @summary Get applicant fraud networks
         * @param {string} applicantId A unique applicant identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFraudNetworksByApplicant: async (applicantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('getFraudNetworksByApplicant', 'applicantId', applicantId)
            const localVarPath = `/resources/applicantFraudNetworks/-/byApplicant/{applicantId}`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicantFraudNetworks/-/byApplicant/{applicantId}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of verification levels.
         * @summary Get available applicant levels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLevels: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/applicants/-/levels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/-/levels',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of required documents.
         * @summary Get required ID documents
         * @param {string} applicantId A unique applicant identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequiredIdDocs: async (applicantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('getRequiredIdDocs', 'applicantId', applicantId)
            const localVarPath = `/resources/applicants/{applicantId}/requiredIdDocs`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/{applicantId}/requiredIdDocs',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns applicant review status.
         * @summary Get applicant review status
         * @param {string} applicantId A unique applicant identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewStatus: async (applicantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('getReviewStatus', 'applicantId', applicantId)
            const localVarPath = `/resources/applicants/{applicantId}/status`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/{applicantId}/status',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about the documents or separate verification step results.
         * @summary Get applicant verification steps status
         * @param {string} applicantId A unique applicant identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerificationStepsStatus: async (applicantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('getVerificationStepsStatus', 'applicantId', applicantId)
            const localVarPath = `/resources/applicants/{applicantId}/requiredIdDocsStatus`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/{applicantId}/requiredIdDocsStatus',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns video call media.
         * @summary Get video call media
         * @param {string} applicantId A unique applicant identifier.
         * @param {string} compositionMediaId Video call media identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoCallMedia: async (applicantId: string, compositionMediaId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('getVideoCallMedia', 'applicantId', applicantId)
            // verify required parameter 'compositionMediaId' is not null or undefined
            assertParamExists('getVideoCallMedia', 'compositionMediaId', compositionMediaId)
            const localVarPath = `/resources/videoIdent/applicant/{applicantId}/media/{compositionMediaId}`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)))
                .replace(`{${"compositionMediaId"}}`, encodeURIComponent(String(compositionMediaId !== undefined ? compositionMediaId : `-compositionMediaId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/videoIdent/applicant/{applicantId}/media/{compositionMediaId}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Imports applicant data and images including associated review results.
         * @summary Import applicant with images by archive
         * @param {ApplicantImportByArchiveRequest} [applicantImportByArchiveRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importByArchive: async (applicantImportByArchiveRequest?: ApplicantImportByArchiveRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/applicants/-/applicantImport`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: applicantImportByArchiveRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/-/applicantImport',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Imports applicants.
         * @summary Import applicants
         * @param {string} [levelName] A [verification level](https://docs.sumsub.com/reference) name. Case-sensitive and has to be created in the same environment. If contains reserved characters (e.g., &#x60;@&#x60;, &#x60;+\&quot;&#x60;, white spaces as &#x60;%20&#x60;), it should be URL-encoded, otherwise you may get signature mismatch.
         * @param {ApplicantImportCompletedRequest} [applicantImportCompletedRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importCompleted: async (levelName?: string, applicantImportCompletedRequest?: ApplicantImportCompletedRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/applicants/-/ingestCompleted?levelName={levelName}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })
            if (levelName !== undefined) {
                localVarQueryParameter['levelName'] = levelName;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: applicantImportCompletedRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/-/ingestCompleted?levelName={levelName}',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiates a check of the applicant profile.
         * @summary Request applicant check
         * @param {string} applicantId A unique applicant identifier.
         * @param {string} [reason] A note indicating the reason for checking the applicant profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateApplicantCheck: async (applicantId: string, reason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('initiateApplicantCheck', 'applicantId', applicantId)
            const localVarPath = `/resources/applicants/{applicantId}/status/pending?reason={reason}`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })
            if (reason !== undefined) {
                localVarQueryParameter['reason'] = reason;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/{applicantId}/status/pending?reason={reason}',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Moves transaction to the specified applicant.
         * @summary Move transaction to another applicant
         * @param {string} txnId A unique transaction identifier.
         * @param {string} applicantId A unique applicant identifier who should own the transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveTransactionToAnotherApplicant: async (txnId: string, applicantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txnId' is not null or undefined
            assertParamExists('moveTransactionToAnotherApplicant', 'txnId', txnId)
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('moveTransactionToAnotherApplicant', 'applicantId', applicantId)
            const localVarPath = `/resources/kyt/txns/{txnId}/applicantId/{applicantId}`
                .replace(`{${"txnId"}}`, encodeURIComponent(String(txnId !== undefined ? txnId : `-txnId-`)))
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/kyt/txns/{txnId}/applicantId/{applicantId}',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes all custom tags from applicant profiles.
         * @summary Remove custom applicant tags
         * @param {string} applicantId A unique applicant identifier.
         * @param {ApplicantRemoveCustomTagsRequest} [applicantRemoveCustomTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCustomTags: async (applicantId: string, applicantRemoveCustomTagsRequest?: ApplicantRemoveCustomTagsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('removeCustomTags', 'applicantId', applicantId)
            const localVarPath = `/resources/applicants/{applicantId}/tags`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: applicantRemoveCustomTagsRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/{applicantId}/tags',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the applicant from the list of company beneficial owners.
         * @summary Remove applicant from beneficiary list
         * @param {string} applicantId A unique company applicant identifier.
         * @param {string} beneficiaryApplicantId Beneficiary applicant identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFromBeneficiaryList: async (applicantId: string, beneficiaryApplicantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('removeFromBeneficiaryList', 'applicantId', applicantId)
            // verify required parameter 'beneficiaryApplicantId' is not null or undefined
            assertParamExists('removeFromBeneficiaryList', 'beneficiaryApplicantId', beneficiaryApplicantId)
            const localVarPath = `/resources/applicants/{applicantId}/info/companyInfo/beneficiaries/{beneficiaryApplicantId}`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)))
                .replace(`{${"beneficiaryApplicantId"}}`, encodeURIComponent(String(beneficiaryApplicantId !== undefined ? beneficiaryApplicantId : `-beneficiaryApplicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/{applicantId}/info/companyInfo/beneficiaries/{beneficiaryApplicantId}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests an applicant action check.
         * @summary Request action check
         * @param {string} actionId A unique applicant action identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestActionCheck: async (actionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            assertParamExists('requestActionCheck', 'actionId', actionId)
            const localVarPath = `/resources/applicantActions/{actionId}/review/status/pending`
                .replace(`{${"actionId"}}`, encodeURIComponent(String(actionId !== undefined ? actionId : `-actionId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicantActions/{actionId}/review/status/pending',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks documents uploaded by the applicant as inactive and deletes all statuses assigned earlier.
         * @summary Reset applicant profile
         * @param {string} applicantId A unique applicant identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetProfile: async (applicantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('resetProfile', 'applicantId', applicantId)
            const localVarPath = `/resources/applicants/{applicantId}/reset`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/{applicantId}/reset',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets the specified verification step.
         * @summary Reset verification step
         * @param {string} applicantId A unique applicant identifier.
         * @param {string} idDocSetType A [step name](ref:reset-single-verification-step#available-steps-to-reset) to reset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetVerificationStep: async (applicantId: string, idDocSetType: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('resetVerificationStep', 'applicantId', applicantId)
            // verify required parameter 'idDocSetType' is not null or undefined
            assertParamExists('resetVerificationStep', 'idDocSetType', idDocSetType)
            const localVarPath = `/resources/applicants/{applicantId}/resetStep/{idDocSetType}`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)))
                .replace(`{${"idDocSetType"}}`, encodeURIComponent(String(idDocSetType !== undefined ? idDocSetType : `-idDocSetType-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/{applicantId}/resetStep/{idDocSetType}',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simulates a verification reposnose.
         * @summary Set review for applicant in sandbox
         * @param {string} applicantId A unique applicant identifier.
         * @param {ApplicantSandboxVerificationResponseRequest} [applicantSandboxVerificationResponseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandboxVerificationResponse: async (applicantId: string, applicantSandboxVerificationResponseRequest?: ApplicantSandboxVerificationResponseRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('sandboxVerificationResponse', 'applicantId', applicantId)
            const localVarPath = `/resources/applicants/{applicantId}/status/testCompleted`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: applicantSandboxVerificationResponseRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/{applicantId}/status/testCompleted',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends applicant data for no-document verification.
         * @summary Submit applicant data
         * @param {string} applicantId A unique applicant identifier.
         * @param {ApplicantSubmitDataNoDocVerificationRequest} [applicantSubmitDataNoDocVerificationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitDataNoDocVerification: async (applicantId: string, applicantSubmitDataNoDocVerificationRequest?: ApplicantSubmitDataNoDocVerificationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('submitDataNoDocVerification', 'applicantId', applicantId)
            const localVarPath = `/resources/applicants/{applicantId}/ekyc/submit`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: applicantSubmitDataNoDocVerificationRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/{applicantId}/ekyc/submit',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits a payment method.
         * @summary Submission
         * @param {string} xExternalActionId Use &#x60;externalActionId&#x60; if you intend to [initialize SDK](ref:about-applicant-actions) for that particular action.
         * @param {string} applicantId A unique applicant identifier.
         * @param {boolean} [requireSelfie] Sets the video selfie at &#x60;requiredIdDocs&#x60; for the action.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitPaymentMethod: async (xExternalActionId: string, applicantId: string, requireSelfie?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xExternalActionId' is not null or undefined
            assertParamExists('submitPaymentMethod', 'xExternalActionId', xExternalActionId)
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('submitPaymentMethod', 'applicantId', applicantId)
            const localVarPath = `/resources/applicantActions/-/forApplicant/{applicantId}/paymentMethod`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })
            if (requireSelfie !== undefined) {
                localVarQueryParameter['requireSelfie'] = requireSelfie;
            }

            if (xExternalActionId != null) {
                localVarHeaderParameter['X-External-Action-Id'] = String(xExternalActionId);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicantActions/-/forApplicant/{applicantId}/paymentMethod',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiates transaction processing.
         * @summary Submit transaction for existing applicant
         * @param {string} applicantId A unique identification number of the applicant who passed user verification (KYC). If you do no have such an applicant, use [Submit transaction for non-existing applicant](ref:submit-transaction-for-non-existing-applicant) instead.
         * @param {ApplicantSubmitTransactionDataRequest} [applicantSubmitTransactionDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitTransactionData: async (applicantId: string, applicantSubmitTransactionDataRequest?: ApplicantSubmitTransactionDataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('submitTransactionData', 'applicantId', applicantId)
            const localVarPath = `/resources/applicants/{applicantId}/kyt/txns/-/data`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: applicantSubmitTransactionDataRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/{applicantId}/kyt/txns/-/data',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiates transaction processing for non-existing applicants.
         * @summary Submit transaction for non-existing applicant
         * @param {string} levelName A [verification level](https://docs.sumsub.com/reference) name. Case-sensitive and has to be created in the same environment. If contains reserved characters (e.g., &#x60;@&#x60;, &#x60;+\&quot;&#x60;, white spaces as &#x60;%20&#x60;), it should be URL-encoded, otherwise you may get signature mismatch.
         * @param {ApplicantSubmitTransactionForNonExistingRequest} [applicantSubmitTransactionForNonExistingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitTransactionForNonExisting: async (levelName: string, applicantSubmitTransactionForNonExistingRequest?: ApplicantSubmitTransactionForNonExistingRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('submitTransactionForNonExisting', 'levelName', levelName)
            const localVarPath = `/resources/applicants/-/kyt/txns/-/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })
            if (levelName !== undefined) {
                localVarQueryParameter['levelName'] = levelName;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: applicantSubmitTransactionForNonExistingRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/-/kyt/txns/-/data',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates information provided when [creating an applicant](ref:create-applicants).
         * @summary Change provided information
         * @param {string} applicantId A unique applicant identifier.
         * @param {ApplicantUpdateFixedInfoRequest} [applicantUpdateFixedInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFixedInfo: async (applicantId: string, applicantUpdateFixedInfoRequest?: ApplicantUpdateFixedInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('updateFixedInfo', 'applicantId', applicantId)
            const localVarPath = `/resources/applicants/{applicantId}/fixedInfo`
                .replace(`{${"applicantId"}}`, encodeURIComponent(String(applicantId !== undefined ? applicantId : `-applicantId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: applicantUpdateFixedInfoRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants/{applicantId}/fixedInfo',
                httpMethod: 'PATCH'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes existing verification level configuration.
         * @summary Change top-level information
         * @param {ApplicantUpdateTopLevelInfoRequest} [applicantUpdateTopLevelInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTopLevelInfo: async (applicantUpdateTopLevelInfoRequest?: ApplicantUpdateTopLevelInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/applicants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-App-Token", keyParamName: "sec0", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: applicantUpdateTopLevelInfoRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/resources/applicants',
                httpMethod: 'PATCH'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicantApi - functional programming interface
 * @export
 */
export const ApplicantApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicantApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds an existing individual applicant as a beneficiary.
         * @summary Add applicant as beneficiary
         * @param {ApplicantApiAddBeneficiaryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addBeneficiary(requestParameters: ApplicantApiAddBeneficiaryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const applicantAddBeneficiaryRequest: ApplicantAddBeneficiaryRequest = {
                applicant: requestParameters.requestBody.applicant,
                applicantId: requestParameters.requestBody.applicantId,
                positions: requestParameters.requestBody.positions,
                type: requestParameters.requestBody.type
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addBeneficiary(requestParameters.applicantId, applicantAddBeneficiaryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a consent to an applicant profile.
         * @summary Add applicant consent
         * @param {ApplicantApiAddConsentToProfileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addConsentToProfile(requestParameters: ApplicantApiAddConsentToProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const applicantAddConsentToProfileRequest: ApplicantAddConsentToProfileRequest = {
                records: requestParameters.records,
                acceptedAt: requestParameters.acceptedAt,
                residenceCountry: requestParameters.residenceCountry
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addConsentToProfile(requestParameters.applicantId, applicantAddConsentToProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds custom tags to applicant profiles.
         * @summary Add custom applicant tags
         * @param {ApplicantApiAddCustomTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCustomTags(requestParameters: ApplicantApiAddCustomTagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const applicantAddCustomTagsRequest: ApplicantAddCustomTagsRequest = {
                RAW_BODY: requestParameters.RAW_BODY
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCustomTags(requestParameters.applicantId, applicantAddCustomTagsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds and overwrites custom tags in applicant profiles.
         * @summary Add and overwrite custom applicant tags
         * @param {ApplicantApiAddCustomTags0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCustomTags_1(requestParameters: ApplicantApiAddCustomTags0Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const applicantAddCustomTagsRequest2: ApplicantAddCustomTagsRequest2 = {
                RAW_BODY: requestParameters.RAW_BODY
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCustomTags_1(requestParameters.applicantId, applicantAddCustomTagsRequest2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds an identification document to be verified.
         * @summary Add ID document
         * @param {ApplicantApiAddIdDocumentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addIdDocument(requestParameters: ApplicantApiAddIdDocumentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicantAddIdDocumentResponse>> {
            const applicantAddIdDocumentRequest: ApplicantAddIdDocumentRequest = {
                metadata: requestParameters.metadata,
                content: requestParameters.content
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addIdDocument(requestParameters.xReturnDocWarnings, requestParameters.applicantId, applicantAddIdDocumentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds an image to the payment method.
         * @summary Add image to payment method
         * @param {ApplicantApiAddImageToPaymentMethodRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addImageToPaymentMethod(requestParameters: ApplicantApiAddImageToPaymentMethodRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const applicantAddImageToPaymentMethodRequest: ApplicantAddImageToPaymentMethodRequest = {
                content: requestParameters.content,
                metadata: requestParameters.metadata
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addImageToPaymentMethod(requestParameters.actionId, applicantAddImageToPaymentMethodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds additional information to the payment method.
         * @summary Add payment method information
         * @param {ApplicantApiAddPaymentMethodInformationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPaymentMethodInformation(requestParameters: ApplicantApiAddPaymentMethodInformationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const applicantAddPaymentMethodInformationRequest: ApplicantAddPaymentMethodInformationRequest = {
                type: requestParameters.type,
                subType: requestParameters.subType,
                data: requestParameters.data
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPaymentMethodInformation(requestParameters.actionId, applicantAddPaymentMethodInformationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add an applicant to blocklist.
         * @summary Add applicant to blocklist
         * @param {ApplicantApiAddToBlocklistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addToBlocklist(requestParameters: ApplicantApiAddToBlocklistRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addToBlocklist(requestParameters.note, requestParameters.applicantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Changes company data.
         * @summary Change company data
         * @param {ApplicantApiChangeCompanyDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeCompanyData(requestParameters: ApplicantApiChangeCompanyDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const applicantChangeCompanyDataRequest: ApplicantChangeCompanyDataRequest = {
                companyName: requestParameters.companyName,
                registrationNumber: requestParameters.registrationNumber,
                country: requestParameters.country,
                legalAddress: requestParameters.legalAddress,
                incorporatedOn: requestParameters.incorporatedOn,
                type: requestParameters.type,
                email: requestParameters.email,
                controlScheme: requestParameters.controlScheme,
                phone: requestParameters.phone,
                taxId: requestParameters.taxId,
                registrationLocation: requestParameters.registrationLocation,
                website: requestParameters.website,
                postalAddress: requestParameters.postalAddress,
                beneficiaries: requestParameters.beneficiaries,
                addresses: requestParameters.addresses
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeCompanyData(requestParameters.applicantId, applicantChangeCompanyDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Changes extracted information.
         * @summary Change information extracted by Sumsub
         * @param {ApplicantApiChangeExtractedInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeExtractedInfo(requestParameters: ApplicantApiChangeExtractedInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const applicantChangeExtractedInfoRequest: ApplicantChangeExtractedInfoRequest = {
                firstName: requestParameters.firstName,
                lastName: requestParameters.lastName,
                middleName: requestParameters.middleName,
                legalName: requestParameters.legalName,
                gender: requestParameters.gender,
                dob: requestParameters.dob,
                placeOfBirth: requestParameters.placeOfBirth,
                countryOfBirth: requestParameters.countryOfBirth,
                stateOfBirth: requestParameters.stateOfBirth,
                country: requestParameters.country,
                nationality: requestParameters.nationality,
                addresses: requestParameters.addresses,
                tin: requestParameters.tin
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeExtractedInfo(requestParameters.applicantId, applicantChangeExtractedInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Changes the list of required documents.
         * @summary Change required document set
         * @param {ApplicantApiChangeRequiredDocumentSetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeRequiredDocumentSet(requestParameters: ApplicantApiChangeRequiredDocumentSetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeRequiredDocumentSet(requestParameters.name, requestParameters.applicantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns rejection reason clarification.
         * @summary Clarify rejection reason
         * @param {ApplicantApiClarifyRejectionReasonRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clarifyRejectionReason(requestParameters: ApplicantApiClarifyRejectionReasonRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clarifyRejectionReason(requestParameters.applicantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Confirms applicant data.
         * @summary Confirm applicant data
         * @param {ApplicantApiConfirmDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmData(requestParameters: ApplicantApiConfirmDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const applicantConfirmDataRequest: ApplicantConfirmDataRequest = {
                otp: requestParameters.otp,
                oauth: requestParameters.oauth
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmData(requestParameters.applicantId, requestParameters.confirmationId, applicantConfirmDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates an applicant action.
         * @summary Create applicant action
         * @param {ApplicantApiCreateActionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAction(requestParameters: ApplicantApiCreateActionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const applicantCreateActionRequest: ApplicantCreateActionRequest = {
                externalActionId: requestParameters.externalActionId,
                paymentMethod: requestParameters.paymentMethod,
                email: requestParameters.email,
                phone: requestParameters.phone
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAction(requestParameters.applicantId, requestParameters.levelName, applicantCreateActionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates an action with transaction information.
         * @summary Submission
         * @param {ApplicantApiCreateCryptoSourceOfFundsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCryptoSourceOfFunds(requestParameters: ApplicantApiCreateCryptoSourceOfFundsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const applicantCreateCryptoSourceOfFundsRequest: ApplicantCreateCryptoSourceOfFundsRequest = {
                currency: requestParameters.currency,
                direction: requestParameters.direction,
                txn: requestParameters.txn,
                address: requestParameters.address,
                tokenId: requestParameters.tokenId
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCryptoSourceOfFunds(requestParameters.applicantId, applicantCreateCryptoSourceOfFundsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates an action to process a payment source and to confirm the owner of the payment method.
         * @summary Create payment source actions
         * @param {ApplicantApiCreatePaymentSourceActionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentSourceActions(requestParameters: ApplicantApiCreatePaymentSourceActionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicantCreatePaymentSourceActionsResponse>> {
            const applicantCreatePaymentSourceActionsRequest: ApplicantCreatePaymentSourceActionsRequest = {
                externalActionId: requestParameters.externalActionId,
                paymentSource: requestParameters.paymentSource
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentSourceActions(requestParameters.applicantId, requestParameters.levelName, applicantCreatePaymentSourceActionsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deactivates an applicant profile.
         * @summary Deactivate applicant profile
         * @param {ApplicantApiDeactivateProfileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateProfile(requestParameters: ApplicantApiDeactivateProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateProfile(requestParameters.applicantId, requestParameters.status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enriches transaction with the Travel Rule data.
         * @summary Enriching transaction with Travel Rule
         * @param {ApplicantApiEnrichTransactionWithTravelRuleDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enrichTransactionWithTravelRuleData(requestParameters: ApplicantApiEnrichTransactionWithTravelRuleDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const applicantEnrichTransactionWithTravelRuleDataRequest: ApplicantEnrichTransactionWithTravelRuleDataRequest = {
                fullName: requestParameters.fullName
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.enrichTransactionWithTravelRuleData(requestParameters.txnId, applicantEnrichTransactionWithTravelRuleDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns information about the applicant action checks.
         * @summary Get action information
         * @param {ApplicantApiGetActionOneInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActionOneInfo(requestParameters: ApplicantApiGetActionOneInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActionOneInfo(requestParameters.actionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of applicant actions.
         * @summary Get applicant actions
         * @param {ApplicantApiGetActionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActions(requestParameters: ApplicantApiGetActionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActions(requestParameters.applicantId, requestParameters.limit, requestParameters.offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an original bank card image.
         * @summary Get bank card image
         * @param {ApplicantApiGetBankCardImageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBankCardImage(requestParameters: ApplicantApiGetBankCardImageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBankCardImage(requestParameters.actionId, requestParameters.imageId, requestParameters.isPreview, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns applicant information.
         * @summary Get applicant data
         * @param {ApplicantApiGetDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getData(requestParameters: ApplicantApiGetDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getData(requestParameters.applicantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns applicant information based on the provided `externalUserId`.
         * @summary Get applicant data (externalUserId)
         * @param {ApplicantApiGetDataByExternalUserIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataByExternalUserId(requestParameters: ApplicantApiGetDataByExternalUserIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataByExternalUserId(requestParameters.externalUserId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the applicant data for Non-Doc verification.
         * @summary Get applicant data
         * @param {ApplicantApiGetDataLatestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataLatest(requestParameters: ApplicantApiGetDataLatestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataLatest(requestParameters.type, requestParameters.applicantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns fraud network by `networkId`.
         * @summary Get fraud network by ID
         * @param {ApplicantApiGetFraudNetworkByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFraudNetworkById(requestParameters: ApplicantApiGetFraudNetworkByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFraudNetworkById(requestParameters.networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns fraud networks.
         * @summary Get fraud networks
         * @param {ApplicantApiGetFraudNetworksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFraudNetworks(requestParameters: ApplicantApiGetFraudNetworksRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFraudNetworks(requestParameters.offset, requestParameters.limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all fraud networks by `applicantId`.
         * @summary Get applicant fraud networks
         * @param {ApplicantApiGetFraudNetworksByApplicantRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFraudNetworksByApplicant(requestParameters: ApplicantApiGetFraudNetworksByApplicantRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFraudNetworksByApplicant(requestParameters.applicantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of verification levels.
         * @summary Get available applicant levels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLevels(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLevels(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of required documents.
         * @summary Get required ID documents
         * @param {ApplicantApiGetRequiredIdDocsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRequiredIdDocs(requestParameters: ApplicantApiGetRequiredIdDocsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRequiredIdDocs(requestParameters.applicantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns applicant review status.
         * @summary Get applicant review status
         * @param {ApplicantApiGetReviewStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviewStatus(requestParameters: ApplicantApiGetReviewStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReviewStatus(requestParameters.applicantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns information about the documents or separate verification step results.
         * @summary Get applicant verification steps status
         * @param {ApplicantApiGetVerificationStepsStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVerificationStepsStatus(requestParameters: ApplicantApiGetVerificationStepsStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVerificationStepsStatus(requestParameters.applicantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns video call media.
         * @summary Get video call media
         * @param {ApplicantApiGetVideoCallMediaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVideoCallMedia(requestParameters: ApplicantApiGetVideoCallMediaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVideoCallMedia(requestParameters.applicantId, requestParameters.compositionMediaId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Imports applicant data and images including associated review results.
         * @summary Import applicant with images by archive
         * @param {ApplicantApiImportByArchiveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importByArchive(requestParameters: ApplicantApiImportByArchiveRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const applicantImportByArchiveRequest: ApplicantImportByArchiveRequest = {
                content: requestParameters.content
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.importByArchive(applicantImportByArchiveRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Imports applicants.
         * @summary Import applicants
         * @param {ApplicantApiImportCompletedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importCompleted(requestParameters: ApplicantApiImportCompletedRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const applicantImportCompletedRequest: ApplicantImportCompletedRequest = {
                info: requestParameters.info,
                externalUserId: requestParameters.externalUserId,
                review: requestParameters.review
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.importCompleted(requestParameters.levelName, applicantImportCompletedRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Initiates a check of the applicant profile.
         * @summary Request applicant check
         * @param {ApplicantApiInitiateApplicantCheckRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiateApplicantCheck(requestParameters: ApplicantApiInitiateApplicantCheckRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initiateApplicantCheck(requestParameters.applicantId, requestParameters.reason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Moves transaction to the specified applicant.
         * @summary Move transaction to another applicant
         * @param {ApplicantApiMoveTransactionToAnotherApplicantRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveTransactionToAnotherApplicant(requestParameters: ApplicantApiMoveTransactionToAnotherApplicantRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveTransactionToAnotherApplicant(requestParameters.txnId, requestParameters.applicantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes all custom tags from applicant profiles.
         * @summary Remove custom applicant tags
         * @param {ApplicantApiRemoveCustomTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeCustomTags(requestParameters: ApplicantApiRemoveCustomTagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const applicantRemoveCustomTagsRequest: ApplicantRemoveCustomTagsRequest = {
                RAW_BODY: requestParameters.RAW_BODY
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeCustomTags(requestParameters.applicantId, applicantRemoveCustomTagsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes the applicant from the list of company beneficial owners.
         * @summary Remove applicant from beneficiary list
         * @param {ApplicantApiRemoveFromBeneficiaryListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeFromBeneficiaryList(requestParameters: ApplicantApiRemoveFromBeneficiaryListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeFromBeneficiaryList(requestParameters.applicantId, requestParameters.beneficiaryApplicantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Requests an applicant action check.
         * @summary Request action check
         * @param {ApplicantApiRequestActionCheckRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestActionCheck(requestParameters: ApplicantApiRequestActionCheckRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestActionCheck(requestParameters.actionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks documents uploaded by the applicant as inactive and deletes all statuses assigned earlier.
         * @summary Reset applicant profile
         * @param {ApplicantApiResetProfileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetProfile(requestParameters: ApplicantApiResetProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetProfile(requestParameters.applicantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resets the specified verification step.
         * @summary Reset verification step
         * @param {ApplicantApiResetVerificationStepRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetVerificationStep(requestParameters: ApplicantApiResetVerificationStepRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetVerificationStep(requestParameters.applicantId, requestParameters.idDocSetType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Simulates a verification reposnose.
         * @summary Set review for applicant in sandbox
         * @param {ApplicantApiSandboxVerificationResponseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sandboxVerificationResponse(requestParameters: ApplicantApiSandboxVerificationResponseRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const applicantSandboxVerificationResponseRequest: ApplicantSandboxVerificationResponseRequest = {
                reviewAnswer: requestParameters.reviewAnswer,
                rejectLabels: requestParameters.rejectLabels,
                reviewRejectType: requestParameters.reviewRejectType,
                clientComment: requestParameters.clientComment,
                moderationComment: requestParameters.moderationComment
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.sandboxVerificationResponse(requestParameters.applicantId, applicantSandboxVerificationResponseRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sends applicant data for no-document verification.
         * @summary Submit applicant data
         * @param {ApplicantApiSubmitDataNoDocVerificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitDataNoDocVerification(requestParameters: ApplicantApiSubmitDataNoDocVerificationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const applicantSubmitDataNoDocVerificationRequest: ApplicantSubmitDataNoDocVerificationRequest = {
                info: requestParameters.info
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitDataNoDocVerification(requestParameters.applicantId, applicantSubmitDataNoDocVerificationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Submits a payment method.
         * @summary Submission
         * @param {ApplicantApiSubmitPaymentMethodRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitPaymentMethod(requestParameters: ApplicantApiSubmitPaymentMethodRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitPaymentMethod(requestParameters.xExternalActionId, requestParameters.applicantId, requestParameters.requireSelfie, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Initiates transaction processing.
         * @summary Submit transaction for existing applicant
         * @param {ApplicantApiSubmitTransactionDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitTransactionData(requestParameters: ApplicantApiSubmitTransactionDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const applicantSubmitTransactionDataRequest: ApplicantSubmitTransactionDataRequest = {
                info: requestParameters.info,
                txnId: requestParameters.txnId,
                txnDate: requestParameters.txnDate,
                applicant: requestParameters.applicant,
                counterparty: requestParameters.counterparty,
                type: requestParameters.type,
                sourceKey: requestParameters.sourceKey,
                props: requestParameters.props
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitTransactionData(requestParameters.applicantId, applicantSubmitTransactionDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Initiates transaction processing for non-existing applicants.
         * @summary Submit transaction for non-existing applicant
         * @param {ApplicantApiSubmitTransactionForNonExistingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitTransactionForNonExisting(requestParameters: ApplicantApiSubmitTransactionForNonExistingRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const applicantSubmitTransactionForNonExistingRequest: ApplicantSubmitTransactionForNonExistingRequest = {
                info: requestParameters.info,
                txnId: requestParameters.txnId,
                txnDate: requestParameters.txnDate,
                props: requestParameters.props,
                applicant: requestParameters.applicant,
                counterparty: requestParameters.counterparty,
                type: requestParameters.type,
                sourceKey: requestParameters.sourceKey
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitTransactionForNonExisting(requestParameters.levelName, applicantSubmitTransactionForNonExistingRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates information provided when [creating an applicant](ref:create-applicants).
         * @summary Change provided information
         * @param {ApplicantApiUpdateFixedInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFixedInfo(requestParameters: ApplicantApiUpdateFixedInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const applicantUpdateFixedInfoRequest: ApplicantUpdateFixedInfoRequest = {
                firstName: requestParameters.firstName,
                lastName: requestParameters.lastName,
                middleName: requestParameters.middleName,
                firstNameEn: requestParameters.firstNameEn,
                lastNameEn: requestParameters.lastNameEn,
                middleNameEn: requestParameters.middleNameEn,
                legalName: requestParameters.legalName,
                gender: requestParameters.gender,
                dob: requestParameters.dob,
                placeOfBirth: requestParameters.placeOfBirth,
                countryOfBirth: requestParameters.countryOfBirth,
                stateOfBirth: requestParameters.stateOfBirth,
                country: requestParameters.country,
                nationality: requestParameters.nationality,
                addresses: requestParameters.addresses,
                tin: requestParameters.tin
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFixedInfo(requestParameters.applicantId, applicantUpdateFixedInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Changes existing verification level configuration.
         * @summary Change top-level information
         * @param {ApplicantApiUpdateTopLevelInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTopLevelInfo(requestParameters: ApplicantApiUpdateTopLevelInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const applicantUpdateTopLevelInfoRequest: ApplicantUpdateTopLevelInfoRequest = {
                id: requestParameters.id,
                externalUserId: requestParameters.externalUserId,
                email: requestParameters.email,
                phone: requestParameters.phone,
                sourceKey: requestParameters.sourceKey,
                lang: requestParameters.lang,
                questionnaires: requestParameters.questionnaires,
                metadata: requestParameters.metadata,
                deleted: requestParameters.deleted
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTopLevelInfo(applicantUpdateTopLevelInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicantApi - factory interface
 * @export
 */
export const ApplicantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicantApiFp(configuration)
    return {
        /**
         * Adds an existing individual applicant as a beneficiary.
         * @summary Add applicant as beneficiary
         * @param {ApplicantApiAddBeneficiaryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBeneficiary(requestParameters: ApplicantApiAddBeneficiaryRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addBeneficiary(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a consent to an applicant profile.
         * @summary Add applicant consent
         * @param {ApplicantApiAddConsentToProfileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addConsentToProfile(requestParameters: ApplicantApiAddConsentToProfileRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addConsentToProfile(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds custom tags to applicant profiles.
         * @summary Add custom applicant tags
         * @param {ApplicantApiAddCustomTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCustomTags(requestParameters: ApplicantApiAddCustomTagsRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addCustomTags(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds and overwrites custom tags in applicant profiles.
         * @summary Add and overwrite custom applicant tags
         * @param {ApplicantApiAddCustomTags0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCustomTags_1(requestParameters: ApplicantApiAddCustomTags0Request, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addCustomTags_1(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds an identification document to be verified.
         * @summary Add ID document
         * @param {ApplicantApiAddIdDocumentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addIdDocument(requestParameters: ApplicantApiAddIdDocumentRequest, options?: AxiosRequestConfig): AxiosPromise<ApplicantAddIdDocumentResponse> {
            return localVarFp.addIdDocument(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds an image to the payment method.
         * @summary Add image to payment method
         * @param {ApplicantApiAddImageToPaymentMethodRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addImageToPaymentMethod(requestParameters: ApplicantApiAddImageToPaymentMethodRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addImageToPaymentMethod(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds additional information to the payment method.
         * @summary Add payment method information
         * @param {ApplicantApiAddPaymentMethodInformationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPaymentMethodInformation(requestParameters: ApplicantApiAddPaymentMethodInformationRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addPaymentMethodInformation(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Add an applicant to blocklist.
         * @summary Add applicant to blocklist
         * @param {ApplicantApiAddToBlocklistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToBlocklist(requestParameters: ApplicantApiAddToBlocklistRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addToBlocklist(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes company data.
         * @summary Change company data
         * @param {ApplicantApiChangeCompanyDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeCompanyData(requestParameters: ApplicantApiChangeCompanyDataRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.changeCompanyData(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes extracted information.
         * @summary Change information extracted by Sumsub
         * @param {ApplicantApiChangeExtractedInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeExtractedInfo(requestParameters: ApplicantApiChangeExtractedInfoRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.changeExtractedInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the list of required documents.
         * @summary Change required document set
         * @param {ApplicantApiChangeRequiredDocumentSetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeRequiredDocumentSet(requestParameters: ApplicantApiChangeRequiredDocumentSetRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.changeRequiredDocumentSet(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns rejection reason clarification.
         * @summary Clarify rejection reason
         * @param {ApplicantApiClarifyRejectionReasonRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clarifyRejectionReason(requestParameters: ApplicantApiClarifyRejectionReasonRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.clarifyRejectionReason(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Confirms applicant data.
         * @summary Confirm applicant data
         * @param {ApplicantApiConfirmDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmData(requestParameters: ApplicantApiConfirmDataRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.confirmData(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an applicant action.
         * @summary Create applicant action
         * @param {ApplicantApiCreateActionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAction(requestParameters: ApplicantApiCreateActionRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createAction(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an action with transaction information.
         * @summary Submission
         * @param {ApplicantApiCreateCryptoSourceOfFundsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCryptoSourceOfFunds(requestParameters: ApplicantApiCreateCryptoSourceOfFundsRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createCryptoSourceOfFunds(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an action to process a payment source and to confirm the owner of the payment method.
         * @summary Create payment source actions
         * @param {ApplicantApiCreatePaymentSourceActionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentSourceActions(requestParameters: ApplicantApiCreatePaymentSourceActionsRequest, options?: AxiosRequestConfig): AxiosPromise<ApplicantCreatePaymentSourceActionsResponse> {
            return localVarFp.createPaymentSourceActions(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivates an applicant profile.
         * @summary Deactivate applicant profile
         * @param {ApplicantApiDeactivateProfileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateProfile(requestParameters: ApplicantApiDeactivateProfileRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deactivateProfile(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Enriches transaction with the Travel Rule data.
         * @summary Enriching transaction with Travel Rule
         * @param {ApplicantApiEnrichTransactionWithTravelRuleDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrichTransactionWithTravelRuleData(requestParameters: ApplicantApiEnrichTransactionWithTravelRuleDataRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.enrichTransactionWithTravelRuleData(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about the applicant action checks.
         * @summary Get action information
         * @param {ApplicantApiGetActionOneInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionOneInfo(requestParameters: ApplicantApiGetActionOneInfoRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getActionOneInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of applicant actions.
         * @summary Get applicant actions
         * @param {ApplicantApiGetActionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActions(requestParameters: ApplicantApiGetActionsRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getActions(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an original bank card image.
         * @summary Get bank card image
         * @param {ApplicantApiGetBankCardImageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBankCardImage(requestParameters: ApplicantApiGetBankCardImageRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getBankCardImage(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns applicant information.
         * @summary Get applicant data
         * @param {ApplicantApiGetDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getData(requestParameters: ApplicantApiGetDataRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getData(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns applicant information based on the provided `externalUserId`.
         * @summary Get applicant data (externalUserId)
         * @param {ApplicantApiGetDataByExternalUserIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataByExternalUserId(requestParameters: ApplicantApiGetDataByExternalUserIdRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getDataByExternalUserId(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the applicant data for Non-Doc verification.
         * @summary Get applicant data
         * @param {ApplicantApiGetDataLatestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataLatest(requestParameters: ApplicantApiGetDataLatestRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getDataLatest(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns fraud network by `networkId`.
         * @summary Get fraud network by ID
         * @param {ApplicantApiGetFraudNetworkByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFraudNetworkById(requestParameters: ApplicantApiGetFraudNetworkByIdRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getFraudNetworkById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns fraud networks.
         * @summary Get fraud networks
         * @param {ApplicantApiGetFraudNetworksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFraudNetworks(requestParameters: ApplicantApiGetFraudNetworksRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getFraudNetworks(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all fraud networks by `applicantId`.
         * @summary Get applicant fraud networks
         * @param {ApplicantApiGetFraudNetworksByApplicantRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFraudNetworksByApplicant(requestParameters: ApplicantApiGetFraudNetworksByApplicantRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getFraudNetworksByApplicant(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of verification levels.
         * @summary Get available applicant levels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLevels(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getLevels(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of required documents.
         * @summary Get required ID documents
         * @param {ApplicantApiGetRequiredIdDocsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequiredIdDocs(requestParameters: ApplicantApiGetRequiredIdDocsRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getRequiredIdDocs(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns applicant review status.
         * @summary Get applicant review status
         * @param {ApplicantApiGetReviewStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewStatus(requestParameters: ApplicantApiGetReviewStatusRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getReviewStatus(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about the documents or separate verification step results.
         * @summary Get applicant verification steps status
         * @param {ApplicantApiGetVerificationStepsStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerificationStepsStatus(requestParameters: ApplicantApiGetVerificationStepsStatusRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getVerificationStepsStatus(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns video call media.
         * @summary Get video call media
         * @param {ApplicantApiGetVideoCallMediaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoCallMedia(requestParameters: ApplicantApiGetVideoCallMediaRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getVideoCallMedia(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Imports applicant data and images including associated review results.
         * @summary Import applicant with images by archive
         * @param {ApplicantApiImportByArchiveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importByArchive(requestParameters: ApplicantApiImportByArchiveRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.importByArchive(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Imports applicants.
         * @summary Import applicants
         * @param {ApplicantApiImportCompletedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importCompleted(requestParameters: ApplicantApiImportCompletedRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.importCompleted(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates a check of the applicant profile.
         * @summary Request applicant check
         * @param {ApplicantApiInitiateApplicantCheckRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateApplicantCheck(requestParameters: ApplicantApiInitiateApplicantCheckRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.initiateApplicantCheck(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Moves transaction to the specified applicant.
         * @summary Move transaction to another applicant
         * @param {ApplicantApiMoveTransactionToAnotherApplicantRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveTransactionToAnotherApplicant(requestParameters: ApplicantApiMoveTransactionToAnotherApplicantRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.moveTransactionToAnotherApplicant(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes all custom tags from applicant profiles.
         * @summary Remove custom applicant tags
         * @param {ApplicantApiRemoveCustomTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCustomTags(requestParameters: ApplicantApiRemoveCustomTagsRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeCustomTags(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the applicant from the list of company beneficial owners.
         * @summary Remove applicant from beneficiary list
         * @param {ApplicantApiRemoveFromBeneficiaryListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFromBeneficiaryList(requestParameters: ApplicantApiRemoveFromBeneficiaryListRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeFromBeneficiaryList(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Requests an applicant action check.
         * @summary Request action check
         * @param {ApplicantApiRequestActionCheckRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestActionCheck(requestParameters: ApplicantApiRequestActionCheckRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.requestActionCheck(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Marks documents uploaded by the applicant as inactive and deletes all statuses assigned earlier.
         * @summary Reset applicant profile
         * @param {ApplicantApiResetProfileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetProfile(requestParameters: ApplicantApiResetProfileRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resetProfile(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Resets the specified verification step.
         * @summary Reset verification step
         * @param {ApplicantApiResetVerificationStepRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetVerificationStep(requestParameters: ApplicantApiResetVerificationStepRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resetVerificationStep(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Simulates a verification reposnose.
         * @summary Set review for applicant in sandbox
         * @param {ApplicantApiSandboxVerificationResponseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandboxVerificationResponse(requestParameters: ApplicantApiSandboxVerificationResponseRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sandboxVerificationResponse(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends applicant data for no-document verification.
         * @summary Submit applicant data
         * @param {ApplicantApiSubmitDataNoDocVerificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitDataNoDocVerification(requestParameters: ApplicantApiSubmitDataNoDocVerificationRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.submitDataNoDocVerification(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Submits a payment method.
         * @summary Submission
         * @param {ApplicantApiSubmitPaymentMethodRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitPaymentMethod(requestParameters: ApplicantApiSubmitPaymentMethodRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.submitPaymentMethod(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates transaction processing.
         * @summary Submit transaction for existing applicant
         * @param {ApplicantApiSubmitTransactionDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitTransactionData(requestParameters: ApplicantApiSubmitTransactionDataRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.submitTransactionData(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates transaction processing for non-existing applicants.
         * @summary Submit transaction for non-existing applicant
         * @param {ApplicantApiSubmitTransactionForNonExistingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitTransactionForNonExisting(requestParameters: ApplicantApiSubmitTransactionForNonExistingRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.submitTransactionForNonExisting(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates information provided when [creating an applicant](ref:create-applicants).
         * @summary Change provided information
         * @param {ApplicantApiUpdateFixedInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFixedInfo(requestParameters: ApplicantApiUpdateFixedInfoRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateFixedInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes existing verification level configuration.
         * @summary Change top-level information
         * @param {ApplicantApiUpdateTopLevelInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTopLevelInfo(requestParameters: ApplicantApiUpdateTopLevelInfoRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateTopLevelInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addBeneficiary operation in ApplicantApi.
 * @export
 * @interface ApplicantApiAddBeneficiaryRequest
 */
export type ApplicantApiAddBeneficiaryRequest = {
    /**
    * A unique company applicant identifier.
    * @type {string}
    * @memberof ApplicantApiAddBeneficiary
    */
    readonly applicantId: string
    /**
    * 
    * @type {ApplicantAddBeneficiaryRequest}
    * @memberof ApplicantApiAddBeneficiary
    */
    readonly requestBody?: ApplicantAddBeneficiaryRequest
}

/**
 * Request parameters for addConsentToProfile operation in ApplicantApi.
 * @export
 * @interface ApplicantApiAddConsentToProfileRequest
 */
export type ApplicantApiAddConsentToProfileRequest = {
    
    /**
    * A unique identifier of an applicant profile to which a consent should be added.
    * @type {string}
    * @memberof ApplicantApiAddConsentToProfile
    */
    readonly applicantId: string
    
} & ApplicantAddConsentToProfileRequest

/**
 * Request parameters for addCustomTags operation in ApplicantApi.
 * @export
 * @interface ApplicantApiAddCustomTagsRequest
 */
export type ApplicantApiAddCustomTagsRequest = {
    
    /**
    * A unique applicant identifier.
    * @type {string}
    * @memberof ApplicantApiAddCustomTags
    */
    readonly applicantId: string
    
} & ApplicantAddCustomTagsRequest

/**
 * Request parameters for addCustomTags_1 operation in ApplicantApi.
 * @export
 * @interface ApplicantApiAddCustomTags0Request
 */
export type ApplicantApiAddCustomTags0Request = {
    
    /**
    * A unique applicant identifier.
    * @type {string}
    * @memberof ApplicantApiAddCustomTags0
    */
    readonly applicantId: string
    
} & ApplicantAddCustomTagsRequest2

/**
 * Request parameters for addIdDocument operation in ApplicantApi.
 * @export
 * @interface ApplicantApiAddIdDocumentRequest
 */
export type ApplicantApiAddIdDocumentRequest = {
    
    /**
    * `true` / `false`
    * @type {boolean}
    * @memberof ApplicantApiAddIdDocument
    */
    readonly xReturnDocWarnings: boolean
    
    /**
    * A unique applicant identifier.
    * @type {string}
    * @memberof ApplicantApiAddIdDocument
    */
    readonly applicantId: string
    
} & ApplicantAddIdDocumentRequest

/**
 * Request parameters for addImageToPaymentMethod operation in ApplicantApi.
 * @export
 * @interface ApplicantApiAddImageToPaymentMethodRequest
 */
export type ApplicantApiAddImageToPaymentMethodRequest = {
    
    /**
    * A unique applicant action identifier.
    * @type {string}
    * @memberof ApplicantApiAddImageToPaymentMethod
    */
    readonly actionId: string
    
} & ApplicantAddImageToPaymentMethodRequest

/**
 * Request parameters for addPaymentMethodInformation operation in ApplicantApi.
 * @export
 * @interface ApplicantApiAddPaymentMethodInformationRequest
 */
export type ApplicantApiAddPaymentMethodInformationRequest = {
    
    /**
    * A unique applicant action identifier.
    * @type {string}
    * @memberof ApplicantApiAddPaymentMethodInformation
    */
    readonly actionId: string
    
} & ApplicantAddPaymentMethodInformationRequest

/**
 * Request parameters for addToBlocklist operation in ApplicantApi.
 * @export
 * @interface ApplicantApiAddToBlocklistRequest
 */
export type ApplicantApiAddToBlocklistRequest = {
    
    /**
    * A note indicating the reason for blocklisting the applicant profile.
    * @type {string}
    * @memberof ApplicantApiAddToBlocklist
    */
    readonly note: string
    
    /**
    * A unique applicant identifier.
    * @type {string}
    * @memberof ApplicantApiAddToBlocklist
    */
    readonly applicantId: string
    
}

/**
 * Request parameters for changeCompanyData operation in ApplicantApi.
 * @export
 * @interface ApplicantApiChangeCompanyDataRequest
 */
export type ApplicantApiChangeCompanyDataRequest = {
    
    /**
    * A unique applicant identifier.
    * @type {string}
    * @memberof ApplicantApiChangeCompanyData
    */
    readonly applicantId: string
    
} & ApplicantChangeCompanyDataRequest

/**
 * Request parameters for changeExtractedInfo operation in ApplicantApi.
 * @export
 * @interface ApplicantApiChangeExtractedInfoRequest
 */
export type ApplicantApiChangeExtractedInfoRequest = {
    
    /**
    * A unique applicant identifier.
    * @type {string}
    * @memberof ApplicantApiChangeExtractedInfo
    */
    readonly applicantId: string
    
} & ApplicantChangeExtractedInfoRequest

/**
 * Request parameters for changeRequiredDocumentSet operation in ApplicantApi.
 * @export
 * @interface ApplicantApiChangeRequiredDocumentSetRequest
 */
export type ApplicantApiChangeRequiredDocumentSetRequest = {
    
    /**
    * A [verification level](https://docs.sumsub.com/reference) name. Case-sensitive and has to be created in the same environment. If contains reserved characters (e.g., `@`, `+\"`, white spaces as `%20`), it should be URL-encoded, otherwise you may get signature mismatch.
    * @type {string}
    * @memberof ApplicantApiChangeRequiredDocumentSet
    */
    readonly name: string
    
    /**
    * A unique applicant identifier.
    * @type {string}
    * @memberof ApplicantApiChangeRequiredDocumentSet
    */
    readonly applicantId: string
    
}

/**
 * Request parameters for clarifyRejectionReason operation in ApplicantApi.
 * @export
 * @interface ApplicantApiClarifyRejectionReasonRequest
 */
export type ApplicantApiClarifyRejectionReasonRequest = {
    
    /**
    * A unique applicant identifier.
    * @type {string}
    * @memberof ApplicantApiClarifyRejectionReason
    */
    readonly applicantId: string
    
}

/**
 * Request parameters for confirmData operation in ApplicantApi.
 * @export
 * @interface ApplicantApiConfirmDataRequest
 */
export type ApplicantApiConfirmDataRequest = {
    
    /**
    * A unique applicant identifier.
    * @type {string}
    * @memberof ApplicantApiConfirmData
    */
    readonly applicantId: string
    
    /**
    * A confirmation identifier from the [submission](ref:submit-applicant-data) response.
    * @type {string}
    * @memberof ApplicantApiConfirmData
    */
    readonly confirmationId: string
    
} & ApplicantConfirmDataRequest

/**
 * Request parameters for createAction operation in ApplicantApi.
 * @export
 * @interface ApplicantApiCreateActionRequest
 */
export type ApplicantApiCreateActionRequest = {
    
    /**
    * A unique aplicant identifier.
    * @type {string}
    * @memberof ApplicantApiCreateAction
    */
    readonly applicantId: string
    
    /**
    * A name of the level configured in the dashboard.
    * @type {string}
    * @memberof ApplicantApiCreateAction
    */
    readonly levelName: string
    
} & ApplicantCreateActionRequest

/**
 * Request parameters for createCryptoSourceOfFunds operation in ApplicantApi.
 * @export
 * @interface ApplicantApiCreateCryptoSourceOfFundsRequest
 */
export type ApplicantApiCreateCryptoSourceOfFundsRequest = {
    
    /**
    * A unique applicant identifier.
    * @type {string}
    * @memberof ApplicantApiCreateCryptoSourceOfFunds
    */
    readonly applicantId: string
    
} & ApplicantCreateCryptoSourceOfFundsRequest

/**
 * Request parameters for createPaymentSourceActions operation in ApplicantApi.
 * @export
 * @interface ApplicantApiCreatePaymentSourceActionsRequest
 */
export type ApplicantApiCreatePaymentSourceActionsRequest = {
    
    /**
    * An unique applicant identifier.
    * @type {string}
    * @memberof ApplicantApiCreatePaymentSourceActions
    */
    readonly applicantId: string
    
    /**
    * A verification level name for which you want to create a payment source action.
    * @type {string}
    * @memberof ApplicantApiCreatePaymentSourceActions
    */
    readonly levelName: string
    
} & ApplicantCreatePaymentSourceActionsRequest

/**
 * Request parameters for deactivateProfile operation in ApplicantApi.
 * @export
 * @interface ApplicantApiDeactivateProfileRequest
 */
export type ApplicantApiDeactivateProfileRequest = {
    
    /**
    * A unique applicant identifier.
    * @type {string}
    * @memberof ApplicantApiDeactivateProfile
    */
    readonly applicantId: string
    
    /**
    * Possible values: `deactivated` to deactivate the applicant profile. `activated` to reactivate the applicant profile.
    * @type {string}
    * @memberof ApplicantApiDeactivateProfile
    */
    readonly status: string
    
}

/**
 * Request parameters for enrichTransactionWithTravelRuleData operation in ApplicantApi.
 * @export
 * @interface ApplicantApiEnrichTransactionWithTravelRuleDataRequest
 */
export type ApplicantApiEnrichTransactionWithTravelRuleDataRequest = {
    
    /**
    * A unique transaction identifier.
    * @type {string}
    * @memberof ApplicantApiEnrichTransactionWithTravelRuleData
    */
    readonly txnId: string
    
} & ApplicantEnrichTransactionWithTravelRuleDataRequest

/**
 * Request parameters for getActionOneInfo operation in ApplicantApi.
 * @export
 * @interface ApplicantApiGetActionOneInfoRequest
 */
export type ApplicantApiGetActionOneInfoRequest = {
    
    /**
    * A unique applicant action identifier.
    * @type {string}
    * @memberof ApplicantApiGetActionOneInfo
    */
    readonly actionId: string
    
}

/**
 * Request parameters for getActions operation in ApplicantApi.
 * @export
 * @interface ApplicantApiGetActionsRequest
 */
export type ApplicantApiGetActionsRequest = {
    
    /**
    * A unique applicant identifier.
    * @type {string}
    * @memberof ApplicantApiGetActions
    */
    readonly applicantId: string
    
    /**
    * Limit of applicant actions to be returned.
    * @type {number}
    * @memberof ApplicantApiGetActions
    */
    readonly limit?: number
    
    /**
    * Offset of applicant actions to be returned.
    * @type {number}
    * @memberof ApplicantApiGetActions
    */
    readonly offset?: number
    
}

/**
 * Request parameters for getBankCardImage operation in ApplicantApi.
 * @export
 * @interface ApplicantApiGetBankCardImageRequest
 */
export type ApplicantApiGetBankCardImageRequest = {
    
    /**
    * A unique applicant action identifier.
    * @type {string}
    * @memberof ApplicantApiGetBankCardImage
    */
    readonly actionId: string
    
    /**
    * An image identifier taken from `images[].imageId`.
    * @type {string}
    * @memberof ApplicantApiGetBankCardImage
    */
    readonly imageId: string
    
    /**
    * Indicates if an image thumbnail should be returned.
    * @type {boolean}
    * @memberof ApplicantApiGetBankCardImage
    */
    readonly isPreview?: boolean
    
}

/**
 * Request parameters for getData operation in ApplicantApi.
 * @export
 * @interface ApplicantApiGetDataRequest
 */
export type ApplicantApiGetDataRequest = {
    
    /**
    * A unique applicant identifier
    * @type {string}
    * @memberof ApplicantApiGetData
    */
    readonly applicantId: string
    
}

/**
 * Request parameters for getDataByExternalUserId operation in ApplicantApi.
 * @export
 * @interface ApplicantApiGetDataByExternalUserIdRequest
 */
export type ApplicantApiGetDataByExternalUserIdRequest = {
    
    /**
    * A unique applicant identifier in your system.
    * @type {string}
    * @memberof ApplicantApiGetDataByExternalUserId
    */
    readonly externalUserId: string
    
}

/**
 * Request parameters for getDataLatest operation in ApplicantApi.
 * @export
 * @interface ApplicantApiGetDataLatestRequest
 */
export type ApplicantApiGetDataLatestRequest = {
    
    /**
    * Check type.
    * @type {'E_KYC_CHECK' | 'RESIDENCY_CHECK'}
    * @memberof ApplicantApiGetDataLatest
    */
    readonly type: 'E_KYC_CHECK' | 'RESIDENCY_CHECK'
    
    /**
    * A unique applicant identifier.
    * @type {string}
    * @memberof ApplicantApiGetDataLatest
    */
    readonly applicantId: string
    
}

/**
 * Request parameters for getFraudNetworkById operation in ApplicantApi.
 * @export
 * @interface ApplicantApiGetFraudNetworkByIdRequest
 */
export type ApplicantApiGetFraudNetworkByIdRequest = {
    
    /**
    * A unique network identifier.
    * @type {string}
    * @memberof ApplicantApiGetFraudNetworkById
    */
    readonly networkId: string
    
}

/**
 * Request parameters for getFraudNetworks operation in ApplicantApi.
 * @export
 * @interface ApplicantApiGetFraudNetworksRequest
 */
export type ApplicantApiGetFraudNetworksRequest = {
    
    /**
    * Offset of the found networks to be returned.
    * @type {number}
    * @memberof ApplicantApiGetFraudNetworks
    */
    readonly offset?: number
    
    /**
    * Maximum number of the found networks to be returned. The maximum value you can set is 100.
    * @type {number}
    * @memberof ApplicantApiGetFraudNetworks
    */
    readonly limit?: number
    
}

/**
 * Request parameters for getFraudNetworksByApplicant operation in ApplicantApi.
 * @export
 * @interface ApplicantApiGetFraudNetworksByApplicantRequest
 */
export type ApplicantApiGetFraudNetworksByApplicantRequest = {
    
    /**
    * A unique applicant identifier.
    * @type {string}
    * @memberof ApplicantApiGetFraudNetworksByApplicant
    */
    readonly applicantId: string
    
}

/**
 * Request parameters for getRequiredIdDocs operation in ApplicantApi.
 * @export
 * @interface ApplicantApiGetRequiredIdDocsRequest
 */
export type ApplicantApiGetRequiredIdDocsRequest = {
    
    /**
    * A unique applicant identifier.
    * @type {string}
    * @memberof ApplicantApiGetRequiredIdDocs
    */
    readonly applicantId: string
    
}

/**
 * Request parameters for getReviewStatus operation in ApplicantApi.
 * @export
 * @interface ApplicantApiGetReviewStatusRequest
 */
export type ApplicantApiGetReviewStatusRequest = {
    
    /**
    * A unique applicant identifier.
    * @type {string}
    * @memberof ApplicantApiGetReviewStatus
    */
    readonly applicantId: string
    
}

/**
 * Request parameters for getVerificationStepsStatus operation in ApplicantApi.
 * @export
 * @interface ApplicantApiGetVerificationStepsStatusRequest
 */
export type ApplicantApiGetVerificationStepsStatusRequest = {
    
    /**
    * A unique applicant identifier.
    * @type {string}
    * @memberof ApplicantApiGetVerificationStepsStatus
    */
    readonly applicantId: string
    
}

/**
 * Request parameters for getVideoCallMedia operation in ApplicantApi.
 * @export
 * @interface ApplicantApiGetVideoCallMediaRequest
 */
export type ApplicantApiGetVideoCallMediaRequest = {
    
    /**
    * A unique applicant identifier.
    * @type {string}
    * @memberof ApplicantApiGetVideoCallMedia
    */
    readonly applicantId: string
    
    /**
    * Video call media identifier.
    * @type {string}
    * @memberof ApplicantApiGetVideoCallMedia
    */
    readonly compositionMediaId: string
    
}

/**
 * Request parameters for importByArchive operation in ApplicantApi.
 * @export
 * @interface ApplicantApiImportByArchiveRequest
 */
export type ApplicantApiImportByArchiveRequest = {
    
} & ApplicantImportByArchiveRequest

/**
 * Request parameters for importCompleted operation in ApplicantApi.
 * @export
 * @interface ApplicantApiImportCompletedRequest
 */
export type ApplicantApiImportCompletedRequest = {
    
    /**
    * A [verification level](https://docs.sumsub.com/reference) name. Case-sensitive and has to be created in the same environment. If contains reserved characters (e.g., `@`, `+\"`, white spaces as `%20`), it should be URL-encoded, otherwise you may get signature mismatch.
    * @type {string}
    * @memberof ApplicantApiImportCompleted
    */
    readonly levelName?: string
    
} & ApplicantImportCompletedRequest

/**
 * Request parameters for initiateApplicantCheck operation in ApplicantApi.
 * @export
 * @interface ApplicantApiInitiateApplicantCheckRequest
 */
export type ApplicantApiInitiateApplicantCheckRequest = {
    
    /**
    * A unique applicant identifier.
    * @type {string}
    * @memberof ApplicantApiInitiateApplicantCheck
    */
    readonly applicantId: string
    
    /**
    * A note indicating the reason for checking the applicant profile.
    * @type {string}
    * @memberof ApplicantApiInitiateApplicantCheck
    */
    readonly reason?: string
    
}

/**
 * Request parameters for moveTransactionToAnotherApplicant operation in ApplicantApi.
 * @export
 * @interface ApplicantApiMoveTransactionToAnotherApplicantRequest
 */
export type ApplicantApiMoveTransactionToAnotherApplicantRequest = {
    
    /**
    * A unique transaction identifier.
    * @type {string}
    * @memberof ApplicantApiMoveTransactionToAnotherApplicant
    */
    readonly txnId: string
    
    /**
    * A unique applicant identifier who should own the transaction.
    * @type {string}
    * @memberof ApplicantApiMoveTransactionToAnotherApplicant
    */
    readonly applicantId: string
    
}

/**
 * Request parameters for removeCustomTags operation in ApplicantApi.
 * @export
 * @interface ApplicantApiRemoveCustomTagsRequest
 */
export type ApplicantApiRemoveCustomTagsRequest = {
    
    /**
    * A unique applicant identifier.
    * @type {string}
    * @memberof ApplicantApiRemoveCustomTags
    */
    readonly applicantId: string
    
} & ApplicantRemoveCustomTagsRequest

/**
 * Request parameters for removeFromBeneficiaryList operation in ApplicantApi.
 * @export
 * @interface ApplicantApiRemoveFromBeneficiaryListRequest
 */
export type ApplicantApiRemoveFromBeneficiaryListRequest = {
    
    /**
    * A unique company applicant identifier.
    * @type {string}
    * @memberof ApplicantApiRemoveFromBeneficiaryList
    */
    readonly applicantId: string
    
    /**
    * Beneficiary applicant identifier.
    * @type {string}
    * @memberof ApplicantApiRemoveFromBeneficiaryList
    */
    readonly beneficiaryApplicantId: string
    
}

/**
 * Request parameters for requestActionCheck operation in ApplicantApi.
 * @export
 * @interface ApplicantApiRequestActionCheckRequest
 */
export type ApplicantApiRequestActionCheckRequest = {
    
    /**
    * A unique applicant action identifier.
    * @type {string}
    * @memberof ApplicantApiRequestActionCheck
    */
    readonly actionId: string
    
}

/**
 * Request parameters for resetProfile operation in ApplicantApi.
 * @export
 * @interface ApplicantApiResetProfileRequest
 */
export type ApplicantApiResetProfileRequest = {
    
    /**
    * A unique applicant identifier.
    * @type {string}
    * @memberof ApplicantApiResetProfile
    */
    readonly applicantId: string
    
}

/**
 * Request parameters for resetVerificationStep operation in ApplicantApi.
 * @export
 * @interface ApplicantApiResetVerificationStepRequest
 */
export type ApplicantApiResetVerificationStepRequest = {
    
    /**
    * A unique applicant identifier.
    * @type {string}
    * @memberof ApplicantApiResetVerificationStep
    */
    readonly applicantId: string
    
    /**
    * A [step name](ref:reset-single-verification-step#available-steps-to-reset) to reset.
    * @type {string}
    * @memberof ApplicantApiResetVerificationStep
    */
    readonly idDocSetType: string
    
}

/**
 * Request parameters for sandboxVerificationResponse operation in ApplicantApi.
 * @export
 * @interface ApplicantApiSandboxVerificationResponseRequest
 */
export type ApplicantApiSandboxVerificationResponseRequest = {
    
    /**
    * A unique applicant identifier.
    * @type {string}
    * @memberof ApplicantApiSandboxVerificationResponse
    */
    readonly applicantId: string
    
} & ApplicantSandboxVerificationResponseRequest

/**
 * Request parameters for submitDataNoDocVerification operation in ApplicantApi.
 * @export
 * @interface ApplicantApiSubmitDataNoDocVerificationRequest
 */
export type ApplicantApiSubmitDataNoDocVerificationRequest = {
    
    /**
    * A unique applicant identifier.
    * @type {string}
    * @memberof ApplicantApiSubmitDataNoDocVerification
    */
    readonly applicantId: string
    
} & ApplicantSubmitDataNoDocVerificationRequest

/**
 * Request parameters for submitPaymentMethod operation in ApplicantApi.
 * @export
 * @interface ApplicantApiSubmitPaymentMethodRequest
 */
export type ApplicantApiSubmitPaymentMethodRequest = {
    
    /**
    * Use `externalActionId` if you intend to [initialize SDK](ref:about-applicant-actions) for that particular action.
    * @type {string}
    * @memberof ApplicantApiSubmitPaymentMethod
    */
    readonly xExternalActionId: string
    
    /**
    * A unique applicant identifier.
    * @type {string}
    * @memberof ApplicantApiSubmitPaymentMethod
    */
    readonly applicantId: string
    
    /**
    * Sets the video selfie at `requiredIdDocs` for the action.
    * @type {boolean}
    * @memberof ApplicantApiSubmitPaymentMethod
    */
    readonly requireSelfie?: boolean
    
}

/**
 * Request parameters for submitTransactionData operation in ApplicantApi.
 * @export
 * @interface ApplicantApiSubmitTransactionDataRequest
 */
export type ApplicantApiSubmitTransactionDataRequest = {
    
    /**
    * A unique identification number of the applicant who passed user verification (KYC). If you do no have such an applicant, use [Submit transaction for non-existing applicant](ref:submit-transaction-for-non-existing-applicant) instead.
    * @type {string}
    * @memberof ApplicantApiSubmitTransactionData
    */
    readonly applicantId: string
    
} & ApplicantSubmitTransactionDataRequest

/**
 * Request parameters for submitTransactionForNonExisting operation in ApplicantApi.
 * @export
 * @interface ApplicantApiSubmitTransactionForNonExistingRequest
 */
export type ApplicantApiSubmitTransactionForNonExistingRequest = {
    
    /**
    * A [verification level](https://docs.sumsub.com/reference) name. Case-sensitive and has to be created in the same environment. If contains reserved characters (e.g., `@`, `+\"`, white spaces as `%20`), it should be URL-encoded, otherwise you may get signature mismatch.
    * @type {string}
    * @memberof ApplicantApiSubmitTransactionForNonExisting
    */
    readonly levelName: string
    
} & ApplicantSubmitTransactionForNonExistingRequest

/**
 * Request parameters for updateFixedInfo operation in ApplicantApi.
 * @export
 * @interface ApplicantApiUpdateFixedInfoRequest
 */
export type ApplicantApiUpdateFixedInfoRequest = {
    
    /**
    * A unique applicant identifier.
    * @type {string}
    * @memberof ApplicantApiUpdateFixedInfo
    */
    readonly applicantId: string
    
} & ApplicantUpdateFixedInfoRequest

/**
 * Request parameters for updateTopLevelInfo operation in ApplicantApi.
 * @export
 * @interface ApplicantApiUpdateTopLevelInfoRequest
 */
export type ApplicantApiUpdateTopLevelInfoRequest = {
    
} & ApplicantUpdateTopLevelInfoRequest

/**
 * ApplicantApiGenerated - object-oriented interface
 * @export
 * @class ApplicantApiGenerated
 * @extends {BaseAPI}
 */
export class ApplicantApiGenerated extends BaseAPI {
    /**
     * Adds an existing individual applicant as a beneficiary.
     * @summary Add applicant as beneficiary
     * @param {ApplicantApiAddBeneficiaryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public addBeneficiary(requestParameters: ApplicantApiAddBeneficiaryRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).addBeneficiary(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a consent to an applicant profile.
     * @summary Add applicant consent
     * @param {ApplicantApiAddConsentToProfileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public addConsentToProfile(requestParameters: ApplicantApiAddConsentToProfileRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).addConsentToProfile(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds custom tags to applicant profiles.
     * @summary Add custom applicant tags
     * @param {ApplicantApiAddCustomTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public addCustomTags(requestParameters: ApplicantApiAddCustomTagsRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).addCustomTags(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds and overwrites custom tags in applicant profiles.
     * @summary Add and overwrite custom applicant tags
     * @param {ApplicantApiAddCustomTags0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public addCustomTags_1(requestParameters: ApplicantApiAddCustomTags0Request, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).addCustomTags_1(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds an identification document to be verified.
     * @summary Add ID document
     * @param {ApplicantApiAddIdDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public addIdDocument(requestParameters: ApplicantApiAddIdDocumentRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).addIdDocument(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds an image to the payment method.
     * @summary Add image to payment method
     * @param {ApplicantApiAddImageToPaymentMethodRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public addImageToPaymentMethod(requestParameters: ApplicantApiAddImageToPaymentMethodRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).addImageToPaymentMethod(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds additional information to the payment method.
     * @summary Add payment method information
     * @param {ApplicantApiAddPaymentMethodInformationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public addPaymentMethodInformation(requestParameters: ApplicantApiAddPaymentMethodInformationRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).addPaymentMethodInformation(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add an applicant to blocklist.
     * @summary Add applicant to blocklist
     * @param {ApplicantApiAddToBlocklistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public addToBlocklist(requestParameters: ApplicantApiAddToBlocklistRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).addToBlocklist(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes company data.
     * @summary Change company data
     * @param {ApplicantApiChangeCompanyDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public changeCompanyData(requestParameters: ApplicantApiChangeCompanyDataRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).changeCompanyData(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes extracted information.
     * @summary Change information extracted by Sumsub
     * @param {ApplicantApiChangeExtractedInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public changeExtractedInfo(requestParameters: ApplicantApiChangeExtractedInfoRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).changeExtractedInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes the list of required documents.
     * @summary Change required document set
     * @param {ApplicantApiChangeRequiredDocumentSetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public changeRequiredDocumentSet(requestParameters: ApplicantApiChangeRequiredDocumentSetRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).changeRequiredDocumentSet(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns rejection reason clarification.
     * @summary Clarify rejection reason
     * @param {ApplicantApiClarifyRejectionReasonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public clarifyRejectionReason(requestParameters: ApplicantApiClarifyRejectionReasonRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).clarifyRejectionReason(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Confirms applicant data.
     * @summary Confirm applicant data
     * @param {ApplicantApiConfirmDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public confirmData(requestParameters: ApplicantApiConfirmDataRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).confirmData(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an applicant action.
     * @summary Create applicant action
     * @param {ApplicantApiCreateActionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public createAction(requestParameters: ApplicantApiCreateActionRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).createAction(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an action with transaction information.
     * @summary Submission
     * @param {ApplicantApiCreateCryptoSourceOfFundsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public createCryptoSourceOfFunds(requestParameters: ApplicantApiCreateCryptoSourceOfFundsRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).createCryptoSourceOfFunds(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an action to process a payment source and to confirm the owner of the payment method.
     * @summary Create payment source actions
     * @param {ApplicantApiCreatePaymentSourceActionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public createPaymentSourceActions(requestParameters: ApplicantApiCreatePaymentSourceActionsRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).createPaymentSourceActions(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivates an applicant profile.
     * @summary Deactivate applicant profile
     * @param {ApplicantApiDeactivateProfileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public deactivateProfile(requestParameters: ApplicantApiDeactivateProfileRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).deactivateProfile(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enriches transaction with the Travel Rule data.
     * @summary Enriching transaction with Travel Rule
     * @param {ApplicantApiEnrichTransactionWithTravelRuleDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public enrichTransactionWithTravelRuleData(requestParameters: ApplicantApiEnrichTransactionWithTravelRuleDataRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).enrichTransactionWithTravelRuleData(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about the applicant action checks.
     * @summary Get action information
     * @param {ApplicantApiGetActionOneInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public getActionOneInfo(requestParameters: ApplicantApiGetActionOneInfoRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).getActionOneInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of applicant actions.
     * @summary Get applicant actions
     * @param {ApplicantApiGetActionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public getActions(requestParameters: ApplicantApiGetActionsRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).getActions(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an original bank card image.
     * @summary Get bank card image
     * @param {ApplicantApiGetBankCardImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public getBankCardImage(requestParameters: ApplicantApiGetBankCardImageRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).getBankCardImage(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns applicant information.
     * @summary Get applicant data
     * @param {ApplicantApiGetDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public getData(requestParameters: ApplicantApiGetDataRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).getData(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns applicant information based on the provided `externalUserId`.
     * @summary Get applicant data (externalUserId)
     * @param {ApplicantApiGetDataByExternalUserIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public getDataByExternalUserId(requestParameters: ApplicantApiGetDataByExternalUserIdRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).getDataByExternalUserId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the applicant data for Non-Doc verification.
     * @summary Get applicant data
     * @param {ApplicantApiGetDataLatestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public getDataLatest(requestParameters: ApplicantApiGetDataLatestRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).getDataLatest(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns fraud network by `networkId`.
     * @summary Get fraud network by ID
     * @param {ApplicantApiGetFraudNetworkByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public getFraudNetworkById(requestParameters: ApplicantApiGetFraudNetworkByIdRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).getFraudNetworkById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns fraud networks.
     * @summary Get fraud networks
     * @param {ApplicantApiGetFraudNetworksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public getFraudNetworks(requestParameters: ApplicantApiGetFraudNetworksRequest = {}, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).getFraudNetworks(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all fraud networks by `applicantId`.
     * @summary Get applicant fraud networks
     * @param {ApplicantApiGetFraudNetworksByApplicantRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public getFraudNetworksByApplicant(requestParameters: ApplicantApiGetFraudNetworksByApplicantRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).getFraudNetworksByApplicant(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of verification levels.
     * @summary Get available applicant levels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public getLevels(options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).getLevels(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of required documents.
     * @summary Get required ID documents
     * @param {ApplicantApiGetRequiredIdDocsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public getRequiredIdDocs(requestParameters: ApplicantApiGetRequiredIdDocsRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).getRequiredIdDocs(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns applicant review status.
     * @summary Get applicant review status
     * @param {ApplicantApiGetReviewStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public getReviewStatus(requestParameters: ApplicantApiGetReviewStatusRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).getReviewStatus(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about the documents or separate verification step results.
     * @summary Get applicant verification steps status
     * @param {ApplicantApiGetVerificationStepsStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public getVerificationStepsStatus(requestParameters: ApplicantApiGetVerificationStepsStatusRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).getVerificationStepsStatus(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns video call media.
     * @summary Get video call media
     * @param {ApplicantApiGetVideoCallMediaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public getVideoCallMedia(requestParameters: ApplicantApiGetVideoCallMediaRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).getVideoCallMedia(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Imports applicant data and images including associated review results.
     * @summary Import applicant with images by archive
     * @param {ApplicantApiImportByArchiveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public importByArchive(requestParameters: ApplicantApiImportByArchiveRequest = {}, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).importByArchive(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Imports applicants.
     * @summary Import applicants
     * @param {ApplicantApiImportCompletedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public importCompleted(requestParameters: ApplicantApiImportCompletedRequest = {}, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).importCompleted(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiates a check of the applicant profile.
     * @summary Request applicant check
     * @param {ApplicantApiInitiateApplicantCheckRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public initiateApplicantCheck(requestParameters: ApplicantApiInitiateApplicantCheckRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).initiateApplicantCheck(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Moves transaction to the specified applicant.
     * @summary Move transaction to another applicant
     * @param {ApplicantApiMoveTransactionToAnotherApplicantRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public moveTransactionToAnotherApplicant(requestParameters: ApplicantApiMoveTransactionToAnotherApplicantRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).moveTransactionToAnotherApplicant(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes all custom tags from applicant profiles.
     * @summary Remove custom applicant tags
     * @param {ApplicantApiRemoveCustomTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public removeCustomTags(requestParameters: ApplicantApiRemoveCustomTagsRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).removeCustomTags(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the applicant from the list of company beneficial owners.
     * @summary Remove applicant from beneficiary list
     * @param {ApplicantApiRemoveFromBeneficiaryListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public removeFromBeneficiaryList(requestParameters: ApplicantApiRemoveFromBeneficiaryListRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).removeFromBeneficiaryList(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requests an applicant action check.
     * @summary Request action check
     * @param {ApplicantApiRequestActionCheckRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public requestActionCheck(requestParameters: ApplicantApiRequestActionCheckRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).requestActionCheck(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks documents uploaded by the applicant as inactive and deletes all statuses assigned earlier.
     * @summary Reset applicant profile
     * @param {ApplicantApiResetProfileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public resetProfile(requestParameters: ApplicantApiResetProfileRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).resetProfile(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resets the specified verification step.
     * @summary Reset verification step
     * @param {ApplicantApiResetVerificationStepRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public resetVerificationStep(requestParameters: ApplicantApiResetVerificationStepRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).resetVerificationStep(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simulates a verification reposnose.
     * @summary Set review for applicant in sandbox
     * @param {ApplicantApiSandboxVerificationResponseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public sandboxVerificationResponse(requestParameters: ApplicantApiSandboxVerificationResponseRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).sandboxVerificationResponse(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends applicant data for no-document verification.
     * @summary Submit applicant data
     * @param {ApplicantApiSubmitDataNoDocVerificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public submitDataNoDocVerification(requestParameters: ApplicantApiSubmitDataNoDocVerificationRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).submitDataNoDocVerification(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submits a payment method.
     * @summary Submission
     * @param {ApplicantApiSubmitPaymentMethodRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public submitPaymentMethod(requestParameters: ApplicantApiSubmitPaymentMethodRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).submitPaymentMethod(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiates transaction processing.
     * @summary Submit transaction for existing applicant
     * @param {ApplicantApiSubmitTransactionDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public submitTransactionData(requestParameters: ApplicantApiSubmitTransactionDataRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).submitTransactionData(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiates transaction processing for non-existing applicants.
     * @summary Submit transaction for non-existing applicant
     * @param {ApplicantApiSubmitTransactionForNonExistingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public submitTransactionForNonExisting(requestParameters: ApplicantApiSubmitTransactionForNonExistingRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).submitTransactionForNonExisting(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates information provided when [creating an applicant](ref:create-applicants).
     * @summary Change provided information
     * @param {ApplicantApiUpdateFixedInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public updateFixedInfo(requestParameters: ApplicantApiUpdateFixedInfoRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).updateFixedInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes existing verification level configuration.
     * @summary Change top-level information
     * @param {ApplicantApiUpdateTopLevelInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicantApiGenerated
     */
    public updateTopLevelInfo(requestParameters: ApplicantApiUpdateTopLevelInfoRequest, options?: AxiosRequestConfig) {
        return ApplicantApiFp(this.configuration).updateTopLevelInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
